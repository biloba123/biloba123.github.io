<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Android获取调试版及发布版安全码SHA1]]></title>
    <url>%2F2017%2F10%2F13%2FAndroid%E8%8E%B7%E5%8F%96%E8%B0%83%E8%AF%95%E7%89%88%E5%8F%8A%E5%8F%91%E5%B8%83%E7%89%88%E5%AE%89%E5%85%A8%E7%A0%81SHA1%2F</url>
    <content type="text"><![CDATA[签名文件签名文件keystore一般有两种：jks后缀或者keystore后缀，Android Studio中创建的为jks后缀，keytool创建的为keystore后缀，两种文件均可用于APP打包。 开发版SHA1：是指在开发调试时，从Android Studio或者Eclipse中直接运行的APP在打包时使用了开发工具默认的开发版（debug）签名文件，开发版签名文件对应有唯一的SHA1。 发布版SHA1：是指在提交测试或发布时，APP签名打包过程中选择的指定签名文件，一般此签名文件为开发者或者开发团队持有，与具体的开发工具无关，发布版签名文件同样也对应有唯一的SHA1。 Android获取SHA1在AndroidStudio中的Terminal中使用keytool命令获取。 发布版SHA11keytool -exportcert -list -v -alias &lt;your-key-name&gt; -keystore &lt;path-to-production-keystore&gt; ：发布版签名文件中key的别名（非必需，如果在创建时没设别名可以去掉-alias ）：替换为自己发布版签名文件的完整路径 例如：keystore放在 C:\android_projects\biloba.jks1keytool -exportcert -list -v -keystore C:\android_projects\biloba.jks 若为keystore类型的文件只用把后缀名换一下。 调试版SHA1调试版keystore默认在 C:\User.android\debug.keystore（Windows下），若为Mac和Linux，此路径应该为~/.android/debug.keystorekeystore的密码默认为android 命令和上面一样，只不过把路径换成默认签名文件所在路径1keytool -exportcert -list -v -keystore C:\Users\23738\.android\debug.keystore]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>keystore</tag>
        <tag>sha1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android平台MQTT使用并实现简单聊天室]]></title>
    <url>%2F2017%2F10%2F11%2FAndroid%E5%B9%B3%E5%8F%B0MQTT%E4%BD%BF%E7%94%A8%E5%B9%B6%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E8%81%8A%E5%A4%A9%E5%AE%A4%2F</url>
    <content type="text"><![CDATA[在上一篇文章介绍了MQTT的原理以及其在NodeMCU上运用实现一些简单的物联网http://www.jianshu.com/p/701f4d31029f但没讲Android APP怎么实现的，那这篇将介绍MQTT协议在Android平台的运用，除了可以用来控制智能硬件，还常实现消息推送和即时通讯im。下面的例子用它来实现一个简单的聊天室 Android中使用MQTT协议添加依赖在gradle中添加依赖，引入相应的库12345dependencies &#123; ... compile &apos;commons-codec:commons-codec:1.5&apos; compile &apos;org.eclipse.paho:org.eclipse.paho.client.mqttv3:1.0.2&apos;&#125; 权限声明123&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt;&lt;uses-permission android:name=&quot;android.permission.WAKE_LOCK&quot;/&gt;&lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot;/&gt; 这些权限不是危险权限，不用运行时申请 MQTT支持类MqttAsyncClient是mqtt支持类，创建时要要传入服务器host，port以及设备标识clientID（不同设备id不能相同）12MqttAsyncClient mqttClient=new MqttAsyncClient(&quot;tcp://&quot;+this.host+&quot;:&quot;+this.port , &quot;ClientID&quot;+this.clientID, new MemoryPersistence()); 接着连接服务器，并对连接状态进行监听123456789101112//注意接口回调都是在非主线程，不能直接进行ui操作mqttClient.connect(getOptions(), null, new IMqttActionListener() &#123; @Override public void onSuccess(IMqttToken asyncActionToken) &#123; //连接成功 &#125; @Override public void onFailure(IMqttToken asyncActionToken, Throwable exception) &#123; //连接失败 &#125; &#125;); getOptions()方法是对连接信息进行配置，如用户名，密码（一般服务器内不设） 1234567891011121314/** * 设置Mqtt的连接信息 */ private MqttConnectOptions getOptions()&#123; MqttConnectOptions options = new MqttConnectOptions(); options.setCleanSession(true);//重连不保持状态 if(this.userID!=null &amp;&amp; this.userID.length()&gt;0 &amp;&amp; this.passWord!=null &amp;&amp; this.passWord.length()&gt;0)&#123; options.setUserName(this.userID);//设置服务器账号密码 options.setPassword(this.passWord.toCharArray()); &#125; options.setConnectionTimeout(10);//设置连接超时时间 options.setKeepAliveInterval(30);//设置保持活动时间，超过时间没有消息收发将会触发ping消息确认 return options; &#125; 最后对消息及连接进行监听1234567891011121314151617//注意接口回调都是在非主线程，不能直接进行ui操作mqttClient.setCallback(new MqttCallback() &#123; @Override public void connectionLost(Throwable cause) &#123; //丢失连接 &#125; @Override public void messageArrived(String topic, MqttMessage message) throws Exception &#123; //接到推送消息 &#125; @Override public void deliveryComplete(IMqttDeliveryToken token) &#123; //发送消息成功到达 &#125; &#125;); 获取并配置好MqttAsyncClient 后就可以调用相应方法订阅Topic接收消息subscribe(String topicFilter, int qos)发送某个Topic的消息publish(String topic, byte[] payload, int qos, boolean retained) 封装为了方便使用，对相关操作进行封装123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218/** * Author：LvQingYang * Date：2017/8/29 * Email：biloba12345@gamil.com * Github：https://github.com/biloba123 * Info：MQTT操作类 */public class MyMqtt &#123; private String TAG = &quot;MyMqtt&quot;; /**MQTT配置参数**/ private static String host = &quot;****************&quot;; private static String port = &quot;*****&quot;; private static String userID = &quot;&quot;; private static String passWord = &quot;&quot;; private static String clientID = UUID.randomUUID().toString(); /**MQTT状态信息**/ private boolean isConnect = false; /**MQTT支持类**/ private MqttAsyncClient mqttClient=null; private MqttListener mMqttListener; private Handler mHandler=new Handler(new Handler.Callback() &#123; @Override public boolean handleMessage(Message message) &#123; switch (message.arg1) &#123; case MqttTag.MQTT_STATE_CONNECTED: if (BuildConfig.DEBUG) Log.d(TAG, &quot;handleMessage: connected&quot;); mMqttListener.onConnected(); break; case MqttTag.MQTT_STATE_FAIL: if (BuildConfig.DEBUG) Log.d(TAG, &quot;handleMessage: fail&quot;); mMqttListener.onFail(); break; case MqttTag.MQTT_STATE_LOST: if (BuildConfig.DEBUG) Log.d(TAG, &quot;handleMessage: lost&quot;); mMqttListener.onLost(); break; case MqttTag.MQTT_STATE_RECEIVE: if (BuildConfig.DEBUG) Log.d(TAG, &quot;handleMessage: receive&quot;); mMqttListener.onReceive((String) message.obj); break; case MqttTag.MQTT_STATE_SEND_SUCC: if (BuildConfig.DEBUG) Log.d(TAG, &quot;handleMessage: send&quot;); mMqttListener.onSendSucc(); break; &#125; return true; &#125; &#125;); /** * 自带的监听类，判断Mqtt活动变化 */ private IMqttActionListener mIMqttActionListener=new IMqttActionListener() &#123; @Override public void onSuccess(IMqttToken asyncActionToken) &#123; isConnect=true; Message msg=new Message(); msg.arg1=MqttTag.MQTT_STATE_CONNECTED; mHandler.sendMessage(msg); &#125; @Override public void onFailure(IMqttToken asyncActionToken, Throwable exception) &#123; isConnect=false; Message msg=new Message(); msg.arg1=MqttTag.MQTT_STATE_FAIL; mHandler.sendMessage(msg); &#125; &#125;; /** * 自带的监听回传类 */ private MqttCallback mMqttCallback=new MqttCallback() &#123; @Override public void connectionLost(Throwable cause) &#123; isConnect=false; Message msg=new Message(); msg.arg1=MqttTag.MQTT_STATE_LOST; mHandler.sendMessage(msg); &#125; @Override public void messageArrived(String topic, MqttMessage message) throws Exception &#123; Message msg=new Message(); msg.arg1=MqttTag.MQTT_STATE_RECEIVE; msg.obj=new String(message.getPayload()); mHandler.sendMessage(msg); &#125; @Override public void deliveryComplete(IMqttDeliveryToken token) &#123; Message msg=new Message(); msg.arg1=MqttTag.MQTT_STATE_SEND_SUCC; mHandler.sendMessage(msg); &#125; &#125;; public MyMqtt(MqttListener lis)&#123; mMqttListener=lis; &#125; public static void setMqttSetting(String host, String port, String userID, String passWord, String clientID)&#123; MyMqtt.host = host; MyMqtt.port = port; MyMqtt.userID = userID; MyMqtt.passWord = passWord; MyMqtt.clientID = clientID; &#125; /** * 进行Mqtt连接 */ public void connectMqtt()&#123; try &#123; mqttClient=new MqttAsyncClient(&quot;tcp://&quot;+this.host+&quot;:&quot;+this.port , &quot;ClientID&quot;+this.clientID, new MemoryPersistence()); mqttClient.connect(getOptions(), null, mIMqttActionListener); mqttClient.setCallback(mMqttCallback); &#125; catch (MqttException e) &#123; e.printStackTrace(); &#125; &#125; /** * 断开Mqtt连接重新连接 */ public void reStartMqtt()&#123; disConnectMqtt(); connectMqtt(); &#125; /** * 断开Mqtt连接 */ public void disConnectMqtt()&#123; try &#123; mqttClient.disconnect(); mqttClient = null; isConnect = false; &#125; catch (MqttException e) &#123; e.printStackTrace(); &#125; &#125; /** * 向Mqtt服务器发送数据 */ public void pubMsg(String Topic, String Msg, int Qos)&#123; if(!isConnect)&#123; Log.d(TAG,&quot;Mqtt连接未打开&quot;); return; &#125; try &#123; /** Topic,Msg,Qos,Retained**/ mqttClient.publish(Topic,Msg.getBytes(),Qos,false); &#125; catch (MqttException e) &#123; e.printStackTrace(); &#125; &#125; /** * 向Mqtt服务器发送数据 */ public void pubMsg(String Topic, byte[] Msg, int Qos)&#123; if(!isConnect)&#123; Log.d(TAG,&quot;Mqtt连接未打开&quot;); return; &#125; try &#123; /** Topic,Msg,Qos,Retained**/ mqttClient.publish(Topic,Msg,Qos,false); &#125; catch (MqttException e) &#123; e.printStackTrace(); &#125; &#125; /** * 向Mqtt服务器订阅某一个Topic */ public void subTopic(String Topic, int Qos)&#123; if(!isConnect)&#123; Log.d(TAG,&quot;Mqtt连接未打开&quot;); return; &#125; try &#123; mqttClient.subscribe(Topic,Qos); &#125; catch (MqttException e) &#123; e.printStackTrace(); &#125; &#125; /** * 设置Mqtt的连接信息 */ private MqttConnectOptions getOptions()&#123; MqttConnectOptions options = new MqttConnectOptions(); options.setCleanSession(true);//重连不保持状态 if(this.userID!=null&amp;&amp;this.userID.length()&gt;0&amp;&amp;this.passWord!=null&amp;&amp;this.passWord.length()&gt;0)&#123; options.setUserName(this.userID);//设置服务器账号密码 options.setPassword(this.passWord.toCharArray()); &#125; options.setConnectionTimeout(10);//设置连接超时时间 options.setKeepAliveInterval(30);//设置保持活动时间，超过时间没有消息收发将会触发ping消息确认 return options; &#125; public boolean isConnect() &#123; return isConnect; &#125;&#125; 相关标识MqttTag1234567public class MqttTag &#123; public final static int MQTT_STATE_CONNECTED=1; public final static int MQTT_STATE_LOST=2; public final static int MQTT_STATE_FAIL=3; public final static int MQTT_STATE_RECEIVE=4; public final static int MQTT_STATE_SEND_SUCC=5;&#125; 接口MqttListener1234567interface MqttListener &#123; void onConnected();//连接成功 void onFail();//连接失败 void onLost();//丢失连接 void onReceive(String message);//接收到消息 void onSendSucc();//消息发送成功&#125; 运用观察者模式，创建一个Service后台监听相关状态（写的不太规范…）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112public class MqttService extends Service implements MqttListener &#123; private static MyMqtt mMyMqtt; private static List&lt;MqttListener&gt; mMqttListenerList=new ArrayList&lt;&gt;(); public static void start(Context context) &#123; Intent starter = new Intent(context, MqttService.class); context.startService(starter); &#125; public static void stop(Context context) &#123; Intent starter = new Intent(context, MqttService.class); context.stopService(starter); &#125; @Override public void onCreate() &#123; super.onCreate(); if (mMyMqtt==null) &#123; mMyMqtt=new MyMqtt(this); &#125; mMyMqtt.connectMqtt(); &#125; @Override public IBinder onBind(Intent intent) &#123; // TODO: Return the communication channel to the service. throw new UnsupportedOperationException(&quot;Not yet implemented&quot;); &#125; @Override public void onDestroy() &#123; super.onDestroy(); mMyMqtt.disConnectMqtt(); mMyMqtt=null; mMqttListenerList.clear(); &#125; public static MyMqtt getMyMqtt()&#123; return mMyMqtt; &#125; public static void addMqttListener(MqttListener listener)&#123; if (!mMqttListenerList.contains(listener)) &#123; mMqttListenerList.add(listener); &#125; &#125; public static void removeMqttListener(MqttListener listener)&#123; mMqttListenerList.remove(listener); &#125; @Override public void onConnected() &#123; for (MqttListener mqttListener : mMqttListenerList) &#123; mqttListener.onConnected(); &#125; &#125; @Override public void onFail() &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; mMyMqtt.connectMqtt(); try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;).start(); for (MqttListener mqttListener : mMqttListenerList) &#123; mqttListener.onFail(); &#125; &#125; @Override public void onLost() &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; mMyMqtt.connectMqtt(); try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;).start(); for (MqttListener mqttListener : mMqttListenerList) &#123; mqttListener.onLost(); &#125; &#125; @Override public void onReceive(String message) &#123; for (MqttListener mqttListener : mMqttListenerList) &#123; mqttListener.onReceive(message); &#125; &#125; @Override public void onSendSucc() &#123; for (MqttListener mqttListener : mMqttListenerList) &#123; mqttListener.onSendSucc(); &#125; &#125;&#125; 简单的聊天室 源码https://github.com/biloba123/ChatRoom开源仓库里还有些其他mqtt示例]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>MQTT</tag>
        <tag>IM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FragmentTabHost的使用和注意事项]]></title>
    <url>%2F2017%2F10%2F07%2FFragmentTabHost%E7%9A%84%E4%BD%BF%E7%94%A8%E5%92%8C%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%2F</url>
    <content type="text"><![CDATA[一般做tab式界面我都是用的BottomNavigationView+Fragment，自己代码控制各fragment的显示和隐藏，这样做代码要多些，如果控制不当可能会在用户重返app时出现fragment重合现象。那偷懒一些的做法可以使用FragmentTabHost+Fragment来实现，只用添加相应Tab就可以，方便很多。 先看实现的效果： 布局文件1234567891011121314151617181920212223242526272829303132333435&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot; tools:context=&quot;com.lvqingyang.mall.MainActivity&quot;&gt; &lt;FrameLayout android:id=&quot;@+id/container&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;0dp&quot; android:layout_weight=&quot;1&quot;&gt; &lt;/FrameLayout&gt; &lt;!--分割线--&gt; &lt;View android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;0.5dp&quot; android:background=&quot;@color/div_darker&quot;/&gt; &lt;android.support.v4.app.FragmentTabHost android:id=&quot;@android:id/tabhost&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:background=&quot;@color/tab_bg&quot;&gt; &lt;FrameLayout android:id=&quot;@android:id/tabcontent&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;0dp&quot;&gt; &lt;/FrameLayout&gt; &lt;/android.support.v4.app.FragmentTabHost&gt;&lt;/LinearLayout&gt; 这里注意FragmentTabHost和它的孩子FrameLayout必须使用android内部id，虽然使用上面container的FrameLayout容纳fragment但FragmentTabHost内的FrameLayout也不能省 代码中初始化1234567891011121314151617181920212223242526272829303132private void initTab() &#123; mTabs=new ArrayList&lt;&gt;(); mTabs.add(new Tab(R.string.home, R.drawable.selector_home, HomeFragment.class)); mTabs.add(new Tab(R.string.hot, R.drawable.selector_hot, HotFragment.class)); mTabs.add(new Tab(R.string.classes, R.drawable.selector_classes, ClassesFragment.class)); mTabs.add(new Tab(R.string.cart, R.drawable.selector_cart, CartFragment.class)); mTabs.add(new Tab(R.string.personal, R.drawable.selector_person, PersonalFragment.class)); //setup tabhost.setup(this, getSupportFragmentManager(), R.id.container); mLayoutInflater=getLayoutInflater(); for (Tab tab : mTabs) &#123; tabhost.addTab(tabhost.newTabSpec(getString(tab.getTextId())) .setIndicator(buildIndicator(tab)), tab.getFragment(), null); &#125; //remove div tabhost.getTabWidget().setDividerDrawable(null); tabhost.setCurrentTab(0); &#125; private View buildIndicator(Tab tab) &#123; View view=mLayoutInflater.inflate(R.layout.indicator, null); TextView tvtitle = (TextView) view.findViewById(R.id.tv_title); ImageView ivicon = (ImageView) view.findViewById(R.id.iv_icon); ivicon.setImageResource(tab.getImgId()); tvtitle.setText(tab.getTextId()); return view; &#125; Tab是简单封装每个tab的信息，包括图标、文字、对应的fragment类。 接下来要调用FragmentTabHost的setup方法，传入FragmentManager和容纳fragment的FrameLayout的id，这样它才能管理这些碎片。 addTab时,第一个参数为TabSpec（传入的tag要唯一），并为它设置indicator。 tabhost默认会在每个tab中间显示分隔线，不想要的话用tabhost.getTabWidget().setDividerDrawable(null); 去掉 最后默认在第一个位置 图标及文字的selector为了让tab选择和未选择下有不同效果，要使用到selector icon的selector12345678&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;selector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;item android:state_pressed=&quot;true&quot; android:drawable=&quot;@mipmap/home_fill&quot;/&gt; &lt;item android:state_selected=&quot;true&quot; android:drawable=&quot;@mipmap/home_fill&quot;/&gt; &lt;item android:drawable=&quot;@mipmap/home&quot;/&gt;&lt;/selector&gt; 文字颜色的selector（注意要放在color目录下，作为color资源，直接指定给textColor属性）12345678&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;selector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;item android:state_pressed=&quot;true&quot; android:color=&quot;#e16531&quot;/&gt; &lt;item android:state_selected=&quot;true&quot; android:color=&quot;#e16531&quot;/&gt; &lt;item android:color=&quot;@color/sub_text_color&quot;/&gt;&lt;/selector&gt; indicator布局1234567891011121314151617181920212223&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:orientation=&quot;vertical&quot; android:gravity=&quot;center&quot; android:paddingTop=&quot;@dimen/sub_small_spacing&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot;&gt; &lt;ImageView android:id=&quot;@+id/iv_icon&quot; android:layout_width=&quot;@dimen/indicator_icon_size&quot; android:layout_height=&quot;@dimen/indicator_icon_size&quot; tools:src=&quot;@mipmap/home_fill&quot;/&gt; &lt;TextView android:id=&quot;@+id/tv_title&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:textSize=&quot;@dimen/sub_small_text&quot; android:layout_marginTop=&quot;@dimen/s_small_spacing&quot; android:layout_marginBottom=&quot;@dimen/s_small_spacing&quot; android:textColor=&quot;@color/selector_text_color&quot; tools:text=&quot;@string/app_name&quot;/&gt;&lt;/LinearLayout&gt; 重用view上面这些代码后就能实现想要的效果，但是会发现每次选中某个fragment都会重新调用它的onCreateView方法，也就是说view不能重用，这里可以在fragment中加入几行代码缓存view，避免每次都要重建view BaseFragment.class1234567891011121314151617181920212223242526272829303132333435363738394041public abstract class BaseFragment extends Fragment&#123; private View mView;//保存View private static final String TAG = &quot;BaseFragment&quot;; @Nullable @Override public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) &#123; if (mView == null) &#123;//为空才inflater mView=inflaterView(inflater, container, savedInstanceState); &#125; ViewGroup parentView= (ViewGroup) mView.getParent(); if (parentView != null) &#123;//如果有parent则移除防止重复添加 parentView.removeView(mView); &#125; initView(mView); setListener(); return mView; &#125; @Override public void onViewCreated(View view, @Nullable Bundle savedInstanceState) &#123; super.onViewCreated(view, savedInstanceState); initData(); setData(); &#125; protected abstract View inflaterView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState); protected abstract void initView(View view); protected abstract void setListener(); protected abstract void initData(); protected abstract void setData();&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>tab</tag>
        <tag>Fragmnet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一步一步来，记全Github命令和用法]]></title>
    <url>%2F2017%2F09%2F15%2F%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E6%9D%A5%EF%BC%8C%E8%AE%B0%E5%85%A8Github%E5%91%BD%E4%BB%A4%E5%92%8C%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[SSH key配置为了在使用github过程中重复输入用户名，密码，通常需要配置生成ssh key，并把它添加到github上，使得远程命令时github能识别我们的机器，并直接给与授权。首先在本机生成一个ssh key1ssh-keygen -t rsa -b 4096 -C &quot;XXXX@example.com&quot; #邮箱用github注册时的邮箱 会问ssh key存放在哪里，默认路径为”/Users/用户名/.ssh”目录，直接回车然后会有两个提示要求输入密码，直接回车，就没有密码，这样就生成了id_rsa和id_rsa.pub文件，存放了ssh key，通过它就可以直接访问github不需要任何密码。复制id_rsa.pub的内容，到你的github账号，点开setting，选择”SSH Keys”,点”New SSH key”,将生成的key绑定上去 通过下面命令测试是否添加成功1ssh -T git@github.com 输出以上信息说明操作成功 项目托管–git remote比如本地有个创建好的AutoBR的项目，想把它托管到github上。那第一步需要在github上创建一个仓库 获取它的地址：git@github.com:biloba123/AutoBR.git，注意地址有两种，一种https形式，另一种ssh格式，我们用ssh这样就不用输密码 然后将本地项目和该仓库关联起来1git remote add origin git@github.com:biloba123/AutoBR.git 这样就向本地仓库添加了一个名为origin，地址是git@github.com:biloba123/AutoBR.git的远程仓库，通过” git remote -v “来查看该项目的远程仓库（一个本地仓库可以和多个远程仓库相关联） 将项目推送到远程仓库–git push关联后，就可以和远程仓库进行数据同步，同步前想把代码提交git commit,推送用到的命令是1git push 远程仓库名 本地分支:远程分支 例如将本地master同步到origin的master分支上1234git push origin master:master#当本地分支和远程一样时也可只写一个git push origin master 删除远程分支，例如删除origin的net分支用下面命令1git push origin :net 更新最新代码–git pull直接git push把代码推送到github上并不是很好的做法，比如你和别人协作时你的代码并不是最新的，直接同步会覆盖覆盖最新代码，上面推送时就有问题 因为远程仓库已经有一些文件，本地项目并没和远程合并，提交被拒绝。首先应该用git pull从github将最新的代码更新到本地，并确保合并成功，如果有冲突，先解决再git push 但是又出现了 fatal: refusing to merge unrelated histories ，这是git 2.9后做了一些更改，在第一次git pull会出问题，用下面命令1git pull origin master --allow-unrelated-histories 输入合并信息，在git push就可以了 git ignore忽略文件有些文件例如apk文件，本机相关配置文件，不需要提交到远程仓库，那就把它们添加到.gitignore文件中]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一步一步来，记全Git命令和用法]]></title>
    <url>%2F2017%2F09%2F14%2F%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E6%9D%A5%EF%BC%8C%E8%AE%B0%E5%85%A8Git%E5%91%BD%E4%BB%A4%E5%92%8C%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Git基本配置Git配置使用git config分三种，存放在不同位置 文件 作用 /etc/gitconfig 系统中对所有的用户都适用的配置。git config –system … ~/.gitconfig 用户目录下的配置文件只适用该用户。git config –global … 当前项目下的.git/config 配置只对当前项目有效。git config … 首先要配置用户名和邮箱。每次git提交都会使用这里配置的默认信息12git config --global user.name &quot;yourname&quot;git config --global user.email ...@example.com 配置默认文本编辑器，例如emacs1git config --global core.editor emacs 配置解决差异冲突时使用哪种分析工具，例如vimdiff1git config --global merge.tool vimdiff 检查已有配置1git config --list 高亮显示一些配置123git config --global color.status auto #查看状态时高亮git config --global color.branch auto #分支名高亮git config --global color.ui auto #自动高亮 配置别名来简化一些命令，例如checkout 简化为co，status简化为st12git config --global alias.co checkoutgit config --global alias.st status 之后使用命令git checkout 时就可以简化为 git co Git基本命令环境配置好了后就可以使用了，常用的git命令就几个不用担心 创建git仓库–git inite在项目根目录下执行git inite命令（在跟目录下右键Git Bash），会在根目录下创建隐藏.Git目录，包含相关配置和信息 查看本地仓库的状态–git status使用git status或之前简化的git st，状态有三种已修改，已暂存，已修改。已修改是在工作目录也就是项目里修改还有提交保存；已暂存是指用git add命令提交到要保存的清单（暂存区域）；已提交是暂存区的文件通过git commit提交到本地git仓库；由于我们新建的仓库，所有文件都没保存提交，都是已修改状态 提交修改到暂存区域–git add通过上面提示可以知道用git add提交，它完整命令参数复杂，只说最常见的两种。一种是添加某个文件，例如app文件1git add app 提交目录下所有文件1git add . 在看看现在状态 已变成暂存状态，并且提示可以使用git rm –cached命令将文件从追踪列表移除 提交到本地仓库–git commit使用git commit将追踪列表中文件提交12git commit -m &quot;提交说明&quot; #形式1：通过-m提交简短信息git commit #形式2：会跳转编辑器，在提交信息有一定格式或文字较多时用 现在工作区是干净的 查看项目历史记录–git log1git log 下载远程项目–git clone当想下载网络上别人的仓库时，可使用git clone “地址”，例如下载我github上一个EmptyHand项目1git clone https://github.com/biloba123/EmptyHand.git 会在当前目录下新建一个EmptyHand文件存放 不同分支–git branch在上面的操作都显示master，因为默认创建一个master的主分支，不同分支互不影响，当我们开发新功能时一般会新建一个分支在上面操作，因为新加功能可能会有问题最后砍掉这个功能，只有测试通过没有问题再把它合并到master分支上。例如现在开发热点功能，新建一个hotspot分支1git branch hotspot 看到现在一共两个分支，当前处于master 切换分支–git checkoutcheckout命令用于签出一个分支或者一个路径。常用于分支切换和恢复文件。列入切换到hotspot分支1git checkout hotspot 现在已经在hotspot分支，我们开发啊开发（几天过去了…），功能差不多实现了将代码保存提交 然而，hotspot出现严重bug，只放弃它12git checkout master #切换回mastergit branch -D hotspot #删除hotspot分支 checkout的另一个常用功能是将文件恢复到修改之前状态。比如今天去在ConnectHotspotFragment.java文件里加了好多好多代码，然而写完发现完全不能用…，而且由于太乱之前代码也不能用了。。。别担心通过下面命令可以恢复1git checkout -- ConnectHotspotFragment.java 合并分支–git merge如果hotspot开发完成没bug，要将它合并到master分支上。首先提交hotspot代码，切换到主分支，再执行git merge hotspot命令，如果没冲突就能直接合并 解决冲突合并并不能经常一帆风顺，比如我现在主要负责这个项目，然后有另一个人协助我，我就把hotspot丢给他做，我也继续在主分支上做，但如果我们同时改了MainActivity，那在合并时 看到代码里 两个分支同时改了这里，所以git不知道该用谁的，这时就要手动合并 然后再git add和commit提交代码即可 为版本打个标签–git tag当完成所有功能并通过测试时，通常会为这个版本打个标签1git tag -a v1.0 -m &quot;相关信息&quot; 也可以通过” git tag -d 标签名 “来删除tag，通过” git show 标签名”查看版本具体信息 帮助文档–git help当你不知道某个命令怎么用时，可以通过 git help 来获取其完整说明。例如查看tag命令说明1git help tag]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[来一套不一样的Toast--自定义Toast]]></title>
    <url>%2F2017%2F09%2F13%2F%E6%9D%A5%E4%B8%80%E5%A5%97%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84Toast--%E8%87%AA%E5%AE%9A%E4%B9%89Toast%2F</url>
    <content type="text"><![CDATA[Android默认ToastAndroid默认Toast只是一个简单的黑框框，有时觉得太单调了，不如自己实现一套较精致，不一样的Toast。先看下效果（动图可能有点大）： 前四个是不同类型的Toast，第五个是个loading框。它们两者实现方式不同，分别进行讲解 不一样的ToastToast其实并不一定要是在底部弹出的黑色小框框，它也自定义不同的样式 自定义显示位置toast的显示位置可以通过 方法setGravity(int gravity, int xOffset, int yOffset)来设置，参数1是位置有Gravity.BOTTOM，Gravity.CENTER，Gravity.CENTER_HORIZONTAL等，参数2,3是相对于x轴，y轴的偏移量，单位为pix，如果想设置为一定数量dp，可以用以下方法将dp转换为pix12final float scale = getContext().getResources().getDisplayMetrics().density;int pixels = (int) (dps * scale + 0.5f); 或者1TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 65, getResources().getDisplayMetrics()); 比如来显示一个相对于屏幕中心x偏上100pix的toast123Toast toast=Toast.makeText(this, &quot;啦啦啦~&quot;,Toast.LENGTH_SHORT);toast.setGravity(Gravity.CENTER,0,-100);toast.show(); 加个图标12345678Toast toast = Toast.makeText(getApplicationContext(), &quot;带图片的Toast&quot;, Toast.LENGTH_LONG);toast.setGravity(Gravity.CENTER, 0, 0);LinearLayout llToast = (LinearLayout) toast.getView();ImageView ivIcon = new ImageView(getApplicationContext());ivIcon.setImageResource(R.drawable.ic_info);llToast.addView(ivIcon, 0);toast.show(); 完全自定义123456Toast toast=Toast.makeText(this, &quot;完全不一样&quot;, Toast.LENGTH_LONG);toast.setGravity(Gravity.CENTER,0,0);View v= getLayoutInflater().inflate(R.layout.toast,null);toast.setView(v);toast.show(); toast.xml123456789101112131415161718192021&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:orientation=&quot;vertical&quot; android:gravity=&quot;center&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:background=&quot;@drawable/bg_toast&quot;&gt; &lt;ImageView android:id=&quot;@+id/iv_icon&quot; android:layout_width=&quot;@dimen/toast_icon_size&quot; android:layout_height=&quot;@dimen/toast_icon_size&quot; android:src=&quot;@drawable/ic_info&quot;/&gt; &lt;TextView android:id=&quot;@+id/tv&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:textColor=&quot;@color/toast_text&quot; android:maxEms=&quot;12&quot; android:layout_marginTop=&quot;@dimen/s_small_spacing&quot; android:textSize=&quot;@dimen/sub_medium_text&quot;/&gt;&lt;/LinearLayout&gt; 效果就是开头动图里面前四种 同样式的loadingloading框的话显示时间不固定，不能用toast来实现，应为它只能显示1.5s或3s，那就用dialog来实现它，这里有一点要注意，就是背景如何做到半透明，并且大小合适12345678910111213View view=LayoutInflater.from(context).inflate (R.layout.toast_loading,null);TextView tv=view.findViewById(R.id.tv);tv.setText(text);AVLoadingIndicatorView avl=view.findViewById(R.id.avl);avl.setIndicator(getIndicator(context));avl.show();dialog=new AlertDialog.Builder(context) .setView(view) .setCancelable(false) .create();dialog.show(); AVLoadingIndicatorView 是一个loadingView的开源库，有多种样式，这里随机获取一种https://github.com/81813780/AVLoadingIndicatorView toast_loading.xml1234567891011121314151617181920212223&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:orientation=&quot;vertical&quot; android:gravity=&quot;center&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:background=&quot;@drawable/bg_toast_loading&quot;&gt; &lt;com.wang.avi.AVLoadingIndicatorView android:id=&quot;@+id/avl&quot; app:indicatorColor=&quot;@color/toast_text&quot; app:indicatorName=&quot;LineScaleIndicator&quot; android:layout_width=&quot;@dimen/toast_icon_size&quot; android:layout_height=&quot;@dimen/toast_icon_size&quot;/&gt; &lt;TextView android:id=&quot;@+id/tv&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:textColor=&quot;@color/toast_text&quot; android:maxEms=&quot;12&quot; android:layout_marginTop=&quot;@dimen/s_small_spacing&quot; android:textSize=&quot;@dimen/sub_medium_text&quot;/&gt;&lt;/LinearLayout&gt; 然而出来的效果 这这效果。。。背景还是纯白，宽度不是wrap_content。这里需要自己写个dialog的theme，如下1234&lt;style name=&quot;CustomDialog&quot; parent=&quot;android:Theme.Dialog&quot;&gt; &lt;item name=&quot;android:windowIsTranslucent&quot;&gt;true&lt;/item&gt; &lt;item name=&quot;android:windowBackground&quot;&gt;@android:color/transparent&lt;/item&gt; &lt;/style&gt; 然后在创建AlertDialog.Builder时传进去123dialog=new AlertDialog.Builder(context,R.style.CustomDialog) .setView(view)... 再看效果 封装类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149import android.content.Context;import android.support.v7.app.AlertDialog;import android.view.Gravity;import android.view.LayoutInflater;import android.view.View;import android.widget.ImageView;import android.widget.TextView;import android.widget.Toast;import com.example.myframe.R;import com.wang.avi.AVLoadingIndicatorView;import java.util.Random;/** * Author：LvQingYang * Date：2017/8/18 * Email：biloba12345@gamil.com * Github：https://github.com/biloba123 *Blog：https://biloba123.github.io/ * Info： */public class MyToast &#123; private static Toast toast; private static AlertDialog dialog; //info toast public static void info(Context context ,String text, int duration)&#123; showToast(context, R.drawable.ic_info, text, duration); &#125; public static void info(Context context ,int textId, int duration)&#123; showToast(context, R.drawable.ic_info,context.getString(textId),duration); &#125; public static void info(Context context ,String text)&#123; showToast(context, R.drawable.ic_info, text, Toast.LENGTH_SHORT); &#125; public static void info(Context context ,int textId)&#123; showToast(context, R.drawable.ic_info,context.getString(textId),Toast.LENGTH_SHORT); &#125; //success public static void success(Context context ,String text, int duration)&#123; showToast(context, R.drawable.ic_success, text, duration); &#125; public static void success(Context context ,int textId, int duration)&#123; showToast(context, R.drawable.ic_success, context.getString(textId),duration); &#125; public static void success(Context context ,String text)&#123; showToast(context, R.drawable.ic_success, text, Toast.LENGTH_SHORT); &#125; public static void success(Context context ,int textId)&#123; showToast(context, R.drawable.ic_success, context.getString(textId),Toast.LENGTH_SHORT); &#125; //error public static void error(Context context ,String text, int duration)&#123; showToast(context, R.drawable.ic_error, text, duration); &#125; public static void error(Context context ,int textId, int duration)&#123; showToast(context, R.drawable.ic_error, context.getString(textId),duration); &#125; public static void error(Context context ,String text)&#123; showToast(context, R.drawable.ic_error, text, Toast.LENGTH_SHORT); &#125; public static void error(Context context ,int textId)&#123; showToast(context, R.drawable.ic_error, context.getString(textId),Toast.LENGTH_SHORT); &#125; //loading public static void loading(Context context ,String text)&#123; View view=LayoutInflater.from(context).inflate (R.layout.toast_loading,null); TextView tv=view.findViewById(R.id.tv); tv.setText(text); AVLoadingIndicatorView avl=view.findViewById(R.id.avl); avl.setIndicator(getIndicator(context)); avl.show(); dialog=new AlertDialog.Builder(context,R.style.CustomDialog) .setView(view) .setCancelable(false) .create(); dialog.show(); &#125; public static void loading(Context context ,int textId)&#123; loading(context, context.getString(textId)); &#125; //warning public static void warning(Context context ,String text, int duration)&#123; showToast(context, R.drawable.ic_warning, text, duration); &#125; public static void warning(Context context ,int textId, int duration)&#123; showToast(context, R.drawable.ic_warning, context.getString(textId),duration); &#125; public static void warning(Context context ,String text)&#123; showToast(context, R.drawable.ic_warning, text, Toast.LENGTH_SHORT); &#125; public static void warning(Context context ,int textId)&#123; showToast(context, R.drawable.ic_warning, context.getString(textId),Toast.LENGTH_SHORT); &#125; public static void cancel()&#123; if (toast != null) &#123; toast.cancel(); &#125; if (dialog != null) &#123; dialog.cancel(); &#125; &#125; static void showToast(Context context, int iconId, String text, int duration)&#123; if (toast != null) &#123; toast.cancel(); &#125; toast=Toast.makeText(context, text, duration); toast.setGravity(Gravity.CENTER,0,0); View v= LayoutInflater.from(context).inflate (R.layout.toast,null); ImageView ivIcon=v.findViewById(R.id.iv_icon); ivIcon.setImageResource(iconId); TextView tv=v.findViewById(R.id.tv); tv.setText(text); toast.setView(v); toast.show(); &#125; private static String getIndicator(Context context) &#123; String[] arrayOfString = context.getResources().getStringArray(R.array.arr_indicator); int i = new Random().nextInt(arrayOfString.length); return arrayOfString[i]; &#125;&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Toast</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Fragment中添加menu]]></title>
    <url>%2F2017%2F09%2F13%2FFragment%E4%B8%AD%E6%B7%BB%E5%8A%A0menu%2F</url>
    <content type="text"><![CDATA[Fragment是Android里面中一个非常灵巧的设计，它可以看做ui模块，由活动托管。熟练的使用它们能优雅的实现很复杂的界面，而且用它们编写UI界面，相对于用一个个Activity所消耗内存少得多，而且切换很流畅，可以参考知乎客户端。 但是，Fragment使用过程中会出现一些小问题，这里讲如何在Fragment中添加menu。我们都知道在活动中添加menu只用编写好menu，在onCreateOptionsMenu中加载，并在onOptionsItemSelected中处理点击事件就可以了，按照这个流程先试下 首先编写menu.xml12345678&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;menu xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&gt; &lt;item android:id=&quot;@+id/item_setting&quot; android:icon=&quot;@drawable/ic_settings&quot; android:title=&quot;@string/setting&quot; app:showAsAction=&quot;always&quot;/&gt;&lt;/menu&gt; 这里只添加一个设置的menu item 然后要加载menu需要toolbar或actionbar，这里分两种情况： 用Activity中actionbar或toolbar，在Fragment中不添加toolbar只需在Activity中初始化好标题栏（用toolbar时要调用setSupportActionBar），在fragment中 12345@Override public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) &#123; inflater.inflate(R.menu.menu_main,menu); super.onCreateOptionsMenu(menu, inflater); &#125; 去除Activity中标题栏，在Fragment中添加toolbar在fragment中初始化标题栏时要注意，fragment中没有setSupportActionBar方法，也就是在标题栏还是要交给托管其的活动来处理，标题栏最终设置到window上，代码如下 123456789101112131415/** * Fragment中初始化Toolbar * @param toolbar * @param title 标题 * @param isDisplayHomeAsUp 是否显示返回箭头 */ public void initToolbar(Toolbar toolbar, String title, boolean isDisplayHomeAsUp) &#123; AppCompatActivity appCompatActivity= (AppCompatActivity) getActivity(); appCompatActivity.setSupportActionBar(toolbar); ActionBar actionBar = appCompatActivity.getSupportActionBar(); if (actionBar != null) &#123; actionBar.setTitle(title); actionBar.setDisplayHomeAsUpEnabled(isDisplayHomeAsUp); &#125; &#125; 然后再调用onCreateOptionsMenu加载到toolbar上 运行一下，你会发现两种情况下menu都没加载出来。原来要在fragment中加载menu还需在其onCreate中加一句 setHasOptionsMenu(true)，用于让活动知道有menu要加载12345@Override public void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setHasOptionsMenu(true); &#125; 现在menu加载出来了 然后重写onOptionsItemSelected处理点击事件12345678910@Override public boolean onOptionsItemSelected(MenuItem item) &#123; switch (item.getItemId()) &#123; case R.id.item_setting: SettingActivity.start(getContext()); return true; default: return super.onOptionsItemSelected(item); &#125; &#125; 现在就大功告成了吗，然而运行后会发现无论怎么点击onOptionsItemSelected都没被调用。可以再android training中找到原因http://developer.android.com/guide/topics/ui/actionbar.html Note: If you added the menu item from a fragment, via the Fragment class’s onCreateOptionsMenu callback, then the system calls the respective onOptionsItemSelected() method for that fragment when the user selects one of the fragment’s items. However the activity gets a chance to handle the event first, so the system calls onOptionsItemSelected() on the activity before calling the same callback for the fragment. 也就是说在虽然在fragment中重写onOptionsItemSelected，但系统会在activity中先调用onOptionsItemSelected，而活动中默认都消耗了点击事件，fragment中因此无法处理点击。所以要先在托管碎片的活动中讲frament中处理的menu item返回false，让点击事件能穿到fragment的onOptionsItemSelected中123456789@Override public boolean onOptionsItemSelected(MenuItem paramMenuItem) &#123; switch (paramMenuItem.getItemId()) &#123; case R.id.item_setting: return false; default: return super.onOptionsItemSelected(paramMenuItem); &#125; &#125; 总结下要在fragment添加menu需要以下步骤： 在fragment的onCreate中添加一句 setHasOptionsMenu(true)； 如果用的是活动的标题栏，只需在onCreateOptionsMenu中加载menu；如果用Fragment自己的toolbar需要先用活动初始化toolbar，然后再onCreateOptionsMenu 在活动中重写onOptionsItemSelected，讲需要在fragment中处理的menu item直接返回false，再在fragment的onOptionsItemSelected中处理]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Fragment</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android样式开发完全指南]]></title>
    <url>%2F2017%2F09%2F11%2FAndroid%E6%A0%B7%E5%BC%8F%E5%BC%80%E5%8F%91%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[记得刚开始学Android时，看着自己完全用系统控件写出的不忍直视的界面，对于如何做出不一样的按钮，让它们在不同状态下有不一样的效果很是好奇。后来才知道了些shape，selector之类，但很长时间以来都没对样式开发做过全面的整理（主要因为懒…），所以有了这篇文章。 好了废话不多说，开始我们的样式开发之旅。因为整理了基本所有的样式，文章可能有点长，可以收藏下来看，当然看的时候也要自己试试效果，不然很容易过几天又忘记了，下次用的时候还要翻一遍。本文将按下面几个模块讲：1. shape：基础的形状定义2. selector：不同状态下的形状变化3. layer-list：多个形状层叠4. drawable：各式drawable和drawable动画5. View Animation：简单的视图动画6. Property Animation：更强大的属性动画7. style和theme 1. shapeshape用来定义基本的形状，一般项目的drawable目录下，布局中各view通过设置android:background属性来引用。 rectangle（矩形，默认的形状）新建一个drawable resource file，取名为bg_btn，来为按钮定义形状，根节点默认是selector，改成shape，shape下能设置多个特性，我们一个一个来看 solid：设置形状填充的颜色，只有android:color一个属性123&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;solid android:color=&quot;@android:color/holo_blue_dark&quot;/&gt;&lt;/shape&gt; 效果和直接设置view的background为颜色一样 padding：设置内容与形状边界的内间距，可分别设置左右上下的距离 android:left 左内间距 android:right 右内间距 android:top 上内间距 android:bottom 下内间距12345&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;solid android:color=&quot;@android:color/holo_blue_dark&quot;/&gt; &lt;padding android:top=&quot;16dp&quot; android:bottom=&quot;16dp&quot;/&gt;&lt;/shape&gt; 当然也和直接设置view的padding一样，不过当你的shape多次使用时，在shape中设置padding就免去为每个控件单独设置padding gradient：设置形状的渐变颜色，可以是线性渐变（linear，默认的渐变类型）辐射渐变（radial ，以圆形从圆形向周围渐变，android:gradientRadius也必须设置）扫描性渐变（sweep ,以一条水平线逆时针扫描渐变） android:type 渐变的类型 android:startColor 渐变开始的颜色 android:endColor 渐变结束的颜色 android:centerColor 渐变中间的颜色 android:angle 渐变的角度，线性渐变时才有效，必须是45的倍数，0表示从左到右，90表示从下到上 android:centerX 渐变中心的相对X坐标，放射渐变时才有效，在0.0到1.0之间，默认为0.5，表示在正中间 android:centerY 渐变中心的相对X坐标，放射渐变时才有效，在0.0到1.0之间，默认为0.5，表示在正中间 android:gradientRadius 渐变的半径，渐变类型为radial时使用 linear渐变效果123456&lt;gradient android:type=&quot;linear&quot; android:startColor=&quot;#18d1ff&quot; android:centerColor=&quot;#4953fd&quot; android:endColor=&quot;#5718bc&quot; android:angle=&quot;0&quot;/&gt;&lt;/shape&gt; 这里的渐变方向由android:angle来设置 radial渐变效果12345678&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;gradient android:type=&quot;radial&quot; android:startColor=&quot;#18d1ff&quot; android:centerColor=&quot;#4953fd&quot; android:endColor=&quot;#5718bc&quot; android:gradientRadius=&quot;160dp&quot;/&gt;&lt;/shape&gt; 渐变中心由(centerX, centerY)确定，比如我们都把它设为0 sweep渐变效果1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;gradient android:type=&quot;sweep&quot; android:startColor=&quot;#18d1ff&quot; android:centerColor=&quot;#4953fd&quot; android:endColor=&quot;#5718bc&quot;/&gt;&lt;/shape&gt; corners：设置圆角，只适用于rectangle类型 android:radius 圆角半径，会被下面每个具体的圆角属性覆盖 android:topLeftRadius 左上角的半径 android:topRightRadius 右上角的半径 android:bottomLeftRadius 左下角的半径 android:bottomRightRadius 右下角的半径1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;gradient android:startColor=&quot;#0564fe&quot; android:centerColor=&quot;#3b45ef&quot; android:endColor=&quot;#6f28e0&quot;/&gt; &lt;corners android:radius=&quot;24dp&quot;/&gt;&lt;/shape&gt; 分别设置topLeftRadius，topRightRadius，bottomLeftRadius stroke：设置描边，实线或虚线 android:color 描边的颜色 android:width 描边的宽度 android:dashWidth 设置虚线时的横线长度 android:dashGap 设置虚线时的横线之间的距离12345&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;stroke android:color=&quot;@android:color/darker_gray&quot; android:width=&quot;2dp&quot;/&gt;&lt;/shape&gt; 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;stroke android:color=&quot;@android:color/darker_gray&quot; android:width=&quot;2dp&quot; android:dashWidth=&quot;4dp&quot; android:dashGap=&quot;6dp&quot;/&gt;&lt;/shape&gt; oval（椭圆形，常用来画圆形）1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:shape=&quot;oval&quot;&gt; &lt;solid android:color=&quot;@android:color/holo_blue_dark&quot;/&gt; &lt;gradient android:type=&quot;radial&quot; android:startColor=&quot;#ffffff&quot; android:endColor=&quot;#a1a1a1&quot; android:gradientRadius=&quot;64dp&quot;/&gt; &lt;size android:height=&quot;128dp&quot; android:width=&quot;128dp&quot;/&gt;&lt;/shape&gt; 这里有个size节点，它是用来设置形状大小的，但一般不用它，比如我们现在把这个圆形设置给一个长宽不相等的控件，那效果还是椭圆，因为shape会被拉伸或压缩。不过我用到radial渐变，想让它从圆心刚好渐变到圆周，所以设置了size，并设置gradientRadius为size长宽的一半，这样无论设置给多大的控件都能正确显示 line（线形，画实线和虚线）12345678&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:shape=&quot;line&quot;&gt; &lt;stroke android:color=&quot;@android:color/darker_gray&quot; android:width=&quot;2dp&quot; android:dashWidth=&quot;4dp&quot; android:dashGap=&quot;6dp&quot;/&gt;&lt;/shape&gt; 画线一般用来分隔内容，上面我们画了一条虚线，把它设置给View，运行出来你发现怎么变成实线了，我要的虚线呢，这不是坑吗？？？ （╯‵□′）╯︵┴─┴原来要想显示出虚线要给View设置android:layerType，为”software”12345&lt;View android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;16dp&quot; android:layerType=&quot;software&quot; android:background=&quot;@drawable/bg_div&quot;/&gt; 画线时，有几点特性必须要知道的： 只能画水平线，画不了竖线； 线的高度是通过stroke的android:width属性设置的； size的android:height属性定义的是整个形状区域的高度； size的height必须大于stroke的width，否则，线无法显示； 线在整个形状区域中是居中显示的； 线左右两边会留有空白间距，线越粗，空白越大； 引用虚线的view需要添加属性android:layerType，值设为”software”，否则显示不了虚线。 ring（环形，可以画环形进度条）shape根元素有些属性只适用于ring类型，先来看看这些属性吧： android:innerRadius 内环的半径 android:innerRadiusRatio 浮点型，以环的宽度比率来表示内环的半径，默认为3，表示内环半径为环的宽度除以3，该值会被android:innerRadius覆盖 android:thickness 环的厚度 android:thicknessRatio 浮点型，以环的宽度比率来表示环的厚度，默认为9，表示环的厚度为环的宽度除以9，该值会被android:thickness覆盖 android:useLevel 一般为false，否则可能环形无法显示，只有作为LevelListDrawable使用时才设为true1234567891011121314&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:shape=&quot;ring&quot; android:innerRadiusRatio=&quot;3&quot; android:thicknessRatio=&quot;12&quot; android:useLevel=&quot;false&quot;&gt; &lt;gradient android:startColor=&quot;@android:color/white&quot; android:endColor=&quot;@android:color/holo_blue_dark&quot; android:type=&quot;sweep&quot; /&gt; &lt;stroke android:width=&quot;2dp&quot; android:color=&quot;@android:color/darker_gray&quot; /&gt;&lt;/shape&gt; 用innerRadiusRatio和thicknessRatio控制环内环和厚度占比是，两个倒数相加不能超过1/2，不然就不是环了，比如这里1/3 + 1/12 &lt; 1/2 但这进度条不会转叫什么进度条，下面会讲到如何让它转起来 2. selector上面我们讲了如何定义各种形状，并设置给控件，但开发中如果想让在不同状态下展示不同形状，比如按钮正常状态下一种形状，点击是另一种形状，这样对用户交互比较好，能让用户得到他操作后的反馈，这就要用到selector。 那首先有必要知道都有哪些状态： android:state_enabled: 设置触摸或点击事件是否可用状态，一般只在false时设置该属性，表示不可用状态 android:state_pressed: 设置是否按压状态，一般在true时设置该属性，表示已按压状态 android:state_selected: 设置是否选中状态，true表示已选中，false表示未选中 android:state_checked: 设置是否勾选状态，主要用于CheckBox和RadioButton，true表示已被勾选，false表示未被勾选 android:state_checkable: 设置勾选是否可用状态，类似state_enabled，只是–state_enabled会影响触摸或点击事件，而state_checkable影响勾选事件 android:state_focused: 设置是否获得焦点状态，true表示获得焦点，默认为false，表示未获得焦点 android:state_window_focused: 设置当前窗口是否获得焦点状态，true表示获得焦点，false表示未获得焦点，例如拉下通知栏或弹出对话框时，当前界面就会失去焦点 android:state_activated: 设置是否被激活状态，true表示被激活，false表示未激活，API Level 11及以上才支持，可通过代码调用控件的setActivated(boolean)方法设置是否激活该控件 android:state_hovered: 设置是否鼠标在上面滑动的状态，true表示鼠标在上面滑动，默认为false，API Level 14及以上才支持 一看到这么多状态是不是感觉头疼，不过平时用到比较多的也就 state_enabled，state_pressed，state_selected，输入框可能会用到state_focused 接下来，看看代码，以下是bg_btn_selector.xml的代码，用于按钮的背景，如果只是背景颜色的变化可以在res下新建一个color文件夹在里面创建selector作为color资源，如果是形状的变化则只能放到drawable下作为drawable资源，也是通过android:background设置给view： color\bg_btn_selector.xml1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;selector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;item android:state_enabled=&quot;false&quot; android:color=&quot;@android:color/darker_gray&quot;/&gt; &lt;item android:state_pressed=&quot;true&quot; android:color=&quot;@android:color/holo_blue_dark&quot;/&gt; &lt;item android:state_selected=&quot;true&quot; android:color=&quot;@android:color/holo_blue_dark&quot;/&gt; &lt;item android:color=&quot;@android:color/holo_blue_light&quot;/&gt;&lt;/selector&gt; android:color只能引用@color drawable\bg_btn_selector.xml1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;selector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;item android:state_enabled=&quot;false&quot; android:drawable=&quot;@drawable/bg_btn_disable&quot;/&gt; &lt;item android:state_pressed=&quot;true&quot; android:drawable=&quot;@drawable/bg_btn_pressed&quot;/&gt; &lt;item android:state_selected=&quot;true&quot; android:drawable=&quot;@drawable/bg_btn_selected&quot;/&gt; &lt;item android:drawable=&quot;@drawable/bg_btn_normal&quot;/&gt;&lt;/selector&gt; android:drawable指定的都是定义的shape，它除了引用@drawable资源，也可以引用@color颜色值 注意：状态是从上往下匹配的，如果匹配到一个item那它就将采用这个item，而不是采用最佳匹配的规则；所以设置默认的状态，一定要写在最后，如果写在前面，则后面所有的item都不会起作用了。 除此之外，selector标签下有两个比较常用的属性，会在状态改变时出现淡入淡出效果，但必须在API Level 11及以上才支持： android:enterFadeDuration 状态改变时，新状态展示时的淡入时间，以毫秒为单位 android:exitFadeDuration 状态改变时，旧状态消失时的淡出时间，以毫秒为单位 3. layer-listshape只能画出矩形，椭圆，线，环这些基本的形状，有时我们需要一些稍微复杂些的形状，一种解决方案是使用图片，但图片要准备不同尺寸以适应不同分辨率手机，太多图片资源会造成安装包过大，其实可以用layer-list来自己实现一些复杂形状 先来看看要实现效果 一个带阴影的button，未点击时阴影窄且深，按压时阴影变宽且颜色变浅。它首先是selector实现123456&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;selector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;item android:state_pressed=&quot;true&quot; android:drawable=&quot;@drawable/bg_btn_pressed&quot;/&gt; &lt;item android:state_selected=&quot;true&quot; android:drawable=&quot;@drawable/bg_btn_selected&quot;/&gt; &lt;item android:drawable=&quot;@drawable/bg_btn_normal&quot;/&gt;&lt;/selector&gt; 来看bg_btn_pressed，bg_btn_selected它们是一样的1234567891011121314151617181920&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;layer-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;!--灰色背景--&gt; &lt;item&gt; &lt;shape&gt; &lt;solid android:color=&quot;#c4c4c4&quot;/&gt; &lt;corners android:radius=&quot;12dp&quot;/&gt; &lt;/shape&gt; &lt;/item&gt; &lt;!--蓝色前景--&gt; &lt;item android:bottom=&quot;6dp&quot; android:right=&quot;6dp&quot;&gt; &lt;shape&gt; &lt;solid android:color=&quot;@android:color/holo_blue_dark&quot;/&gt; &lt;corners android:radius=&quot;12dp&quot;/&gt; &lt;/shape&gt; &lt;/item&gt;&lt;/layer-list&gt; layer-list作为根节点，也可以作为selector中item的子节点。layer-list可以添加多个item子节点，每个item子节点对应一个drawable资源，按照item从上到下的顺序叠加在一起，再通过设置每个item的偏移量就可以看到阴影效果了。layer-list的item可以通过下面四个属性设置偏移量： android:top 顶部的偏移量 android:bottom 底部的偏移量 android:left 左边的偏移量 android:right 右边的偏移量 这四个偏移量和控件的margin设置差不多，都是外间距的效果。如何不设置偏移量，前面的图层就完全挡住了后面的图层，从而也看不到后面的图层效果了。 然后是bg_btn_normal.xml1234567891011121314151617181920212223242526272829&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;layer-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;!--透明背景--&gt; &lt;item&gt; &lt;shape&gt; &lt;solid android:color=&quot;@android:color/transparent&quot;/&gt; &lt;corners android:radius=&quot;12dp&quot;/&gt; &lt;/shape&gt; &lt;/item&gt; &lt;!--灰色背景--&gt; &lt;item android:bottom=&quot;3dp&quot; android:right=&quot;3dp&quot;&gt; &lt;shape&gt; &lt;solid android:color=&quot;#bebebe&quot;/&gt; &lt;corners android:radius=&quot;12dp&quot;/&gt; &lt;/shape&gt; &lt;/item&gt; &lt;!--蓝色前景--&gt; &lt;item android:bottom=&quot;6dp&quot; android:right=&quot;6dp&quot;&gt; &lt;shape&gt; &lt;solid android:color=&quot;@android:color/holo_blue_light&quot;/&gt; &lt;corners android:radius=&quot;12dp&quot;/&gt; &lt;/shape&gt; &lt;/item&gt;&lt;/layer-list&gt; 第一个item是一个透明的shape，再在它上面加阴影效果，应为直接加阴影的话，normal状态时button的大小要比按压时大，看起来不太好。这里保证蓝色前景也就是按钮大小不变的情况下，按压时将透明shape那部分变成阴影，并且阴影变淡，这就达到效果了 4. drawable除了上面讲的shape,selector,layer-list，Android还有很多其他drawable资源 普通图片图片格式可以是png(最常用，推荐使用)、jpg、gif，用图片资源需要根据不同屏幕密度提供多张不同尺寸的图片： 密度分类 密度值范围 代表分辨率 图标尺寸 mdpi 120~160dpi 320x480px 48x48px hdpi 160~240dpi 480x800px 72x72px xhdpi 240~320dpi 720x1280px 96x96px xxhdpi 320~480dpi 1080x1920px 144x144px xxxhdpi 480~640dpi 1440x2560px 192x192px 一张图片一般需要提供5张不同比例的图片，切图的话可以用下面这个网站在线切http://icon.wuruihong.com/Android Studio中也可以用Image Assetl来导入符合Materical Design设计的应用常用图标 Vector Drawable普通图片需要提供多张不同尺寸的图片，这会加大安装包的大小。而从Android 5.0开始支持的Vector可以自动进行适配，不需要通过分辨率来设置不同的图片，可以大幅减少图像的体积，同样一张图，用Vector来实现，可能只有PNG的几十分之一 利用Android Studio的Vector Asset，可以非常方便的创建Vector图像，也可以直接通过本地的SVG图像来生成Vector图像 level-listlevel-list管理一组drawable，每个drawable设置一组level范围，最终会根据level值选取对应的drawable绘制出来。level-list通过添加item子标签来添加相应的drawable，其下的item只有三个属性： android:drawable 指定drawable资源，如果不设置该属性，也可以定义drawable类型的子标签 android:minLevel 该item的最小level值 android:maxLevel 该item的最大level值 用它来实现比如电量，信号强弱显示12345678910111213141516171819&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;level-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;item android:maxLevel=&quot;100&quot; android:minLevel=&quot;100&quot; android:drawable=&quot;@drawable/ic_battery_full_black_24dp&quot;/&gt; &lt;item android:maxLevel=&quot;99&quot; android:minLevel=&quot;90&quot; android:drawable=&quot;@drawable/ic_battery_90_black_24dp&quot;/&gt; &lt;item android:maxLevel=&quot;89&quot; android:minLevel=&quot;80&quot; android:drawable=&quot;@drawable/ic_battery_80_black_24dp&quot;/&gt; &lt;item android:maxLevel=&quot;79&quot; android:minLevel=&quot;60&quot; android:drawable=&quot;@drawable/ic_battery_60_black_24dp&quot;/&gt; &lt;item android:maxLevel=&quot;59&quot; android:minLevel=&quot;50&quot; android:drawable=&quot;@drawable/ic_battery_50_black_24dp&quot;/&gt; &lt;item android:maxLevel=&quot;49&quot; android:minLevel=&quot;30&quot; android:drawable=&quot;@drawable/ic_battery_30_black_24dp&quot;/&gt; &lt;item android:maxLevel=&quot;29&quot; android:minLevel=&quot;20&quot; android:drawable=&quot;@drawable/ic_battery_20_black_24dp&quot;/&gt; &lt;item android:maxLevel=&quot;19&quot; android:minLevel=&quot;0&quot; android:drawable=&quot;@drawable/ic_battery_alert_black_24dp&quot;/&gt;&lt;/level-list&gt; 设置给ImageView12345&lt;ImageView android:id=&quot;@+id/iv_battery&quot; android:layout_width=&quot;64dp&quot; android:layout_height=&quot;64dp&quot; android:src=&quot;@drawable/battery_level&quot;/&gt; 代码中通过getDrawable().setLevel(level)设置level，这里每点一下减少10%电量123level-=10;tvbattery.setText(level+&quot;&quot;);ivbattery.getDrawable().setLevel(level); item的匹配规则是从上到下的，当设置的level值与前面的item的level范围匹配，则采用。当从大到小排序下来，可以去掉每个item的android:maxLevel属性，比如上面，从小到大则可以去掉android:minLevel animation-listanimation-list可以将一系列drawable构建成帧动画，就是将一个个drawable，一帧一帧的播放。通过添加item子标签设置每一帧使用的drawable资源，以及每一帧持续的时间。123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;animation-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:oneshot=&quot;false&quot;&gt; &lt;item android:drawable=&quot;@drawable/ic_wifi_signal_0&quot; android:duration=&quot;1000&quot;/&gt; &lt;item android:drawable=&quot;@drawable/ic_wifi_signal_1&quot; android:duration=&quot;1000&quot;/&gt; &lt;item android:drawable=&quot;@drawable/ic_wifi_signal_2&quot; android:duration=&quot;1000&quot;/&gt; &lt;item android:drawable=&quot;@drawable/ic_wifi_signal_3&quot; android:duration=&quot;1000&quot;/&gt; &lt;item android:drawable=&quot;@drawable/ic_wifi_signal_4&quot; android:duration=&quot;1000&quot;/&gt;&lt;/animation-list&gt; android:oneshot属性设置是否循环播放，设为true时，只播放一轮就结束，设为false时，则会轮询播放。 android:duration属性设置该帧持续的时间，以毫秒数为单位。设置给ImageView，在代码中1((AnimationDrawable)iv.getDrawable()).start(); animation-list对应的Drawable类为AnimationDrawable，要让动画运行起来，需要主动调用AnimationDrawable的start()方法。另外，如果在Activity的onCreate()方法里直接调用start()方法会没有效果，因为view还没有初始化完成是播放不了动画的。 animated-rotateanimated-rotate会让drawable不停地做旋转动画（不用在代码中启动）animated-rotate可设置的属性只有四个： android:drawable 指定drawable资源，如果不设置该属性，也可以定义drawable类型的子标签 android:pivotX 旋转中心的X坐标 android:pivotY 旋转中心的Y坐标123456&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;animated-rotate xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:drawable=&quot;@drawable/bg_progressv&quot; android:pivotX=&quot;50%&quot; android:pivotY=&quot;50%&quot;&gt;&lt;/animated-rotate&gt; 注意：50%不能写成0.5, 它们是不同的意思，50%是相对于控件，0.5是相对于整个屏幕 ##5. View Animation未完]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>shape</tag>
        <tag>drawable</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MQTT--服务器搭建]]></title>
    <url>%2F2017%2F09%2F11%2FMQTT--%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[MQTT由IBM的Andy Stanford-Clark博士和Arcom的Arlen Nipper（现为Eurotech）于1999年发明。 MQTT代表MQ遥测传输。它是针对受限设备和低带宽，高延迟或不可靠网络设计的发布/订阅，非常简单和轻便的消息传递协议。设计原则是尽量减少网络带宽和设备资源需求，同时还要确保可靠性和一定程度的交付保证。这些原则还可以使协议成为连接设备新兴的“机器对机器”（M2M）或“物联网”世界的理想选择，以及带宽和电池电量非常高的移动应用。 前言最近要用arduino开发自主借还书的demo，通过mqtt协议发布数据到服务器，然后用APP订阅相应Topic接收数据，做相应处理。第一步先是搭建mqtt服务器，现在开源mqtt的broker比较多，最后还是选择了Apollo。当然如果不想自己搭建也可以用相应平台，比如阿里云的消息队列中有mqtt，以及物联网平台onenet等等（但是用他们要设置各种key和id，我试了能够连接，但publish始终不行，不知道是哪里设置错了） 搭建MQTT服务器 下载apollo下载地址http://activemq.apache.org/apollo/download.html 解压得到下面这些文件 bin下包含apollo和apollo.cmd两个文件 打开cmd进入到bin目录下，输入apollo.cmd create mybrokermybroker是服务器名字任意，服务器实例包含了所有的配置，运行时数据等，并且和一个服务器进程关联。（注意：这里需要java环境，没得要下载jdk，并配置环境变量） 完成后会多出一个mybroker文件夹 其中etc中包含相关配置文件，apollo.xml是配置服务器信息的文件，users.properties文件包含连接MQTT服务器时用到的用户名和密码，后面登录网页会介绍，可以修改原始的admin=password，可以接着换行添加新的用户名密码。 打开mybroker的bin目录，cmd进入到bin目录下，输入apollo-broker.cmd run开始运行，关闭cmd后会停止。或者可以install并run apollo-broker-service，让它长期在后台运行 在浏览器中输入http://127.0.0.1:61680/或https://127.0.0.1:61681/进入web管理页面，输入默认admin，password 队列和发布的Topic 连上的设备 配置页面 很多教程说到上面就没了，然后你试着用连接发现根本连不上，其实打开apollo.xml仔细看你会发现少配置了一个选项导致的，可以直接在web页面改 这两处取消注释就可以连接上了，修改后保存会重新载入配置文件 其他在apollo.xml中 上面两行是web管理登入链接，下面第一个是tcp方式连接是端口，可以自行更改，比如一般默认1883端口]]></content>
      <categories>
        <category>Arduino</category>
      </categories>
      <tags>
        <tag>MQTT</tag>
        <tag>Arduino</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MQTT--NodeMCU及MQTT接发消息体验]]></title>
    <url>%2F2017%2F09%2F11%2FMQTT--NodeMCU%E5%8F%8AMQTT%E6%8E%A5%E5%8F%91%E6%B6%88%E6%81%AF%E4%BD%93%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[使用MQTT先要有一个MQTT服务器，具体如何搭建可以看上一篇文章http://www.jianshu.com/p/e11a47f1e53c 这一篇主要讲下NodeMCU的使用，以及MQTT介绍和如何接发消息 NodeMCUESP8266介绍介绍NodeMCU前需要先了解ESP8266，它是一个完整自称体系的WiFi网络解决方案，能独立运行也可为从部件连接单片机运行 具有以下特点： 超小尺寸 低功耗 内置TCP/IP协议 可编程 低成本 NodeMCU介绍NodeMCU是一款基于ESP8266模块的开源硬件，符合Arduino框架。同时可使用Node.js编程 WiFi测试先要安装Arduino IDE For ESP8266Arduino IDE For ESP8266是根据Arduino修改的专门烧写ESP8266开发板的IDE。在装好Arduino IDE后： 打开Arduino 文件-&gt;首选项，在 附加开发管理网站 中填入http://arduino.esp8266.com/stable/package_esp8266com_index.json，然后点击确定保存 重启IDE后，打开 工具-&gt;开发板-&gt;开发板管理器；搜索ESP8266，选择esp 8266 by ESP8266 Community安装 下载完成后可以在开发板选项中看到ESP8266 Module,以及NodeMCU等可选开发板 将NodeMCU通过usb连接到电脑，在工具下选择相应配置 波特率越大烧录程序速度越快但有可能出错端口选择NodeMCU对应端口，如果没看到端口，那是驱动没有装，装驱动可以看这里http://www.arduino.cn/thread-1008-1-1.html 打开示例选择ESP8266WiFi中的WiFiScan 烧到板子上打开窗口监视器可以看到扫描出来的附近热点 MQTTMQTT介绍消息队列遥测传输(MQTT)是IBM开发的即时通讯协议，为计算能力有限且工作在低带宽、不可靠网络的传感器或控制设备而设计。比如对于移动开发，它可以用于消息推送，即时通讯等等 特性： 发布/订阅的消息模式，提供一对多的消息发布 使用TCP/IP提供网络连接 有三种消息发布服务质量，至多一次，至少一次，只有一次 传输小、开销小 LastWill通知中断机制 MQTT原理介绍 客户端：发布者(Publish)、订阅者(SubScribe)，客户端有ID,ID冲突会挤掉先连接客户端。 服务器端：代理(Broker) 消息：主题(Topic)+负载(payload) 举个场景为例： QQ用户2(账号QQ1000)向QQ用户1(QQ9999)发送消息“Hello World”.发送者：QQ用户2订阅者：QQ用户1消息：QQ9999+”Hello World”. 消息发送至服务器，服务器查找QQ9999对应的用户后，发送信息给QQ用户2. MQTT ESP8266库菜单“项目”-“加载库”-“管理库”，搜索安装“PubSubClient” PubSubClient有一些示例可以打开mqtt_esp8266看下 MQTT接发消息体验这里做两个示例1. NodeMCU发布消息：光照强度传感器测得环境光照强度发布到服务器，手机订阅该Topic接收光强信息 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;ESP8266WiFi.h&gt;#include &lt;PubSubClient.h&gt;int pinLED = D2;const char* ssid = &quot;********&quot;;//连接的路由器的名字const char* password = &quot;********&quot;;//连接的路由器的密码const char* mqtt_server = &quot;********&quot;;//服务器的地址 const int port=****;//服务器端口号WiFiClient espClient;PubSubClient client(espClient);int light=255;void setup_wifi() &#123;//自动连WIFI接入网络 delay(10); WiFi.begin(ssid, password); while (WiFi.status() != WL_CONNECTED) &#123; delay(500); Serial.print(&quot;...&quot;); &#125;&#125;void callback(char* topic, byte* payload, unsigned int length) &#123;//用于接收数据 int l=0; int p=1; for (int i = length-1; i &gt;=0; i--) &#123; l+=(int)((char)payload[i]-&apos;0&apos;)*p; p*=10; &#125; light=l; Serial.println(l);//换行&#125;void reconnect() &#123;//等待，直到连接上服务器 while (!client.connected()) &#123;//如果没有连接上 if (client.connect(&quot;biloba&quot;)+random(999999999)) &#123;//接入时的用户名，尽量取一个很不常用的用户名 client.subscribe(&quot;LED&quot;);//接收外来的数据时的intopic &#125; else &#123; Serial.print(&quot;failed, rc=&quot;);//连接失败 Serial.print(client.state());//重新连接 Serial.println(&quot; try again in 5 seconds&quot;);//延时5秒后重新连接 delay(5000); &#125; &#125;&#125;void setup() &#123;//初始化程序，只运行一遍 Serial.begin(9600);//设置串口波特率（与烧写用波特率不是一个概念） setup_wifi();//自动连WIFI接入网络 client.setServer(mqtt_server, port);//端口号 client.setCallback(callback); //用于接收服务器接收的数据&#125;void loop() &#123;//主循环 reconnect();//确保连上服务器，否则一直等待。 client.loop();//MUC接收数据的主循环函数。 analogWrite(pinLED,light);&#125; 先使用ESP8266WiFi库的方法连接一个wifi，连接成功后loop中获取光强并转换为json格式，发布到light的Topic主题下，可以打开服务器web管理页面，可以在Topic找到它 接着试着用手机app订阅接收传感器发的消息（具体Android端如何实现下篇文章会讲到），在google play中下载一个myMqtt的APP，不方便的可以在这里下http://pan.baidu.com/s/1slE0cw9 打开APP，在setting中设置你服务器ip，端口等保存，如果顶部显示绿色表明连接成功，在Subscribe中订阅light主题，返回到Dashboard就能实时收到消息 1. NodeMCU接收消息：连接一个led灯，用手机APP控制灯的亮度1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;ESP8266WiFi.h&gt;#include &lt;PubSubClient.h&gt;#include &lt;math.h&gt;int pinLED = D2;const char* ssid = &quot;********&quot;;//连接的路由器的名字const char* password = &quot;********&quot;;//连接的路由器的密码const char* mqtt_server = &quot;********&quot;;//服务器的地址 const int port=****;//服务器端口号WiFiClient espClient;PubSubClient client(espClient);int light=1024;//led的亮度值void setup_wifi() &#123;//自动连WIFI接入网络 delay(10); WiFi.begin(ssid, password); while (WiFi.status() != WL_CONNECTED) &#123; delay(500); Serial.print(&quot;...&quot;); &#125;&#125;void callback(char* topic, byte* payload, unsigned int length) &#123;//用于接收数据 //将char* 转换为int int l=0; int p=1; for (int i = length-1; i &gt;=0; i--) &#123; l+=(int)((char)payload[i]-&apos;0&apos;)*p; p*=10; &#125; light=l;//赋值给light Serial.println(l);&#125;void reconnect() &#123;//等待，直到连接上服务器 while (!client.connected()) &#123;//如果没有连接上 if (client.connect(&quot;biloba&quot;)+random(999999999)) &#123;//接入时的用户名，尽量取一个很不常用的用户名 client.subscribe(&quot;LED&quot;);//接收外来的数据时的intopic &#125; else &#123; Serial.print(&quot;failed, rc=&quot;);//连接失败 Serial.print(client.state());//重新连接 Serial.println(&quot; try again in 5 seconds&quot;);//延时5秒后重新连接 delay(5000); &#125; &#125;&#125;void setup() &#123;//初始化程序，只运行一遍 Serial.begin(9600);//设置串口波特率（与烧写用波特率不是一个概念） setup_wifi();//自动连WIFI接入网络 client.setServer(mqtt_server, port);//端口号 client.setCallback(callback); //用于接收服务器接收的数据&#125;void loop() &#123;//主循环 reconnect();//确保连上服务器，否则一直等待。 client.loop();//MUC接收数据的主循环函数。 analogWrite(pinLED,light);//设置led亮度&#125; 代码跟上面没太大区别，只不过这里不发信息了，而接收LED Topic的信息，接收到转换为int设置为灯的亮度，这样就实现远程app控灯。打开myMqtt的publish，输入Topic为LED，Message为灯的亮度（0-1024），可以实时控制灯]]></content>
      <categories>
        <category>Arduino</category>
      </categories>
      <tags>
        <tag>MQTT</tag>
        <tag>Arduino</tag>
        <tag>NodeMCU</tag>
      </tags>
  </entry>
</search>
