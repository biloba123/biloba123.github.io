<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[来一套不一样的Toast--自定义Toast]]></title>
    <url>%2F2017%2F09%2F13%2F%E6%9D%A5%E4%B8%80%E5%A5%97%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84Toast--%E8%87%AA%E5%AE%9A%E4%B9%89Toast%2F</url>
    <content type="text"><![CDATA[Android默认ToastAndroid默认Toast只是一个简单的黑框框，有时觉得太单调了，不如自己实现一套较精致，不一样的Toast。先看下效果（动图可能有点大）： 前四个是不同类型的Toast，第五个是个loading框。它们两者实现方式不同，分别进行讲解 不一样的ToastToast其实并不一定要是在底部弹出的黑色小框框，它也自定义不同的样式 自定义显示位置toast的显示位置可以通过 方法setGravity(int gravity, int xOffset, int yOffset)来设置，参数1是位置有Gravity.BOTTOM，Gravity.CENTER，Gravity.CENTER_HORIZONTAL等，参数2,3是相对于x轴，y轴的偏移量，单位为pix，如果想设置为一定数量dp，可以用以下方法将dp转换为pix12final float scale = getContext().getResources().getDisplayMetrics().density;int pixels = (int) (dps * scale + 0.5f); 或者1TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 65, getResources().getDisplayMetrics()); 比如来显示一个相对于屏幕中心x偏上100pix的toast123Toast toast=Toast.makeText(this, &quot;啦啦啦~&quot;,Toast.LENGTH_SHORT);toast.setGravity(Gravity.CENTER,0,-100);toast.show(); 加个图标12345678Toast toast = Toast.makeText(getApplicationContext(), &quot;带图片的Toast&quot;, Toast.LENGTH_LONG);toast.setGravity(Gravity.CENTER, 0, 0);LinearLayout llToast = (LinearLayout) toast.getView();ImageView ivIcon = new ImageView(getApplicationContext());ivIcon.setImageResource(R.drawable.ic_info);llToast.addView(ivIcon, 0);toast.show(); 完全自定义123456Toast toast=Toast.makeText(this, &quot;完全不一样&quot;, Toast.LENGTH_LONG);toast.setGravity(Gravity.CENTER,0,0);View v= getLayoutInflater().inflate(R.layout.toast,null);toast.setView(v);toast.show(); toast.xml123456789101112131415161718192021&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:orientation=&quot;vertical&quot; android:gravity=&quot;center&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:background=&quot;@drawable/bg_toast&quot;&gt; &lt;ImageView android:id=&quot;@+id/iv_icon&quot; android:layout_width=&quot;@dimen/toast_icon_size&quot; android:layout_height=&quot;@dimen/toast_icon_size&quot; android:src=&quot;@drawable/ic_info&quot;/&gt; &lt;TextView android:id=&quot;@+id/tv&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:textColor=&quot;@color/toast_text&quot; android:maxEms=&quot;12&quot; android:layout_marginTop=&quot;@dimen/s_small_spacing&quot; android:textSize=&quot;@dimen/sub_medium_text&quot;/&gt;&lt;/LinearLayout&gt; 效果就是开头动图里面前四种 同样式的loadingloading框的话显示时间不固定，不能用toast来实现，应为它只能显示1.5s或3s，那就用dialog来实现它，这里有一点要注意，就是背景如何做到半透明，并且大小合适12345678910111213View view=LayoutInflater.from(context).inflate (R.layout.toast_loading,null);TextView tv=view.findViewById(R.id.tv);tv.setText(text);AVLoadingIndicatorView avl=view.findViewById(R.id.avl);avl.setIndicator(getIndicator(context));avl.show();dialog=new AlertDialog.Builder(context) .setView(view) .setCancelable(false) .create();dialog.show(); AVLoadingIndicatorView 是一个loadingView的开源库，有多种样式，这里随机获取一种https://github.com/81813780/AVLoadingIndicatorView toast_loading.xml1234567891011121314151617181920212223&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:orientation=&quot;vertical&quot; android:gravity=&quot;center&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:background=&quot;@drawable/bg_toast_loading&quot;&gt; &lt;com.wang.avi.AVLoadingIndicatorView android:id=&quot;@+id/avl&quot; app:indicatorColor=&quot;@color/toast_text&quot; app:indicatorName=&quot;LineScaleIndicator&quot; android:layout_width=&quot;@dimen/toast_icon_size&quot; android:layout_height=&quot;@dimen/toast_icon_size&quot;/&gt; &lt;TextView android:id=&quot;@+id/tv&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:textColor=&quot;@color/toast_text&quot; android:maxEms=&quot;12&quot; android:layout_marginTop=&quot;@dimen/s_small_spacing&quot; android:textSize=&quot;@dimen/sub_medium_text&quot;/&gt;&lt;/LinearLayout&gt; 然而出来的效果 这这效果。。。背景还是纯白，宽度不是wrap_content。这里需要自己写个dialog的theme，如下1234&lt;style name=&quot;CustomDialog&quot; parent=&quot;android:Theme.Dialog&quot;&gt; &lt;item name=&quot;android:windowIsTranslucent&quot;&gt;true&lt;/item&gt; &lt;item name=&quot;android:windowBackground&quot;&gt;@android:color/transparent&lt;/item&gt; &lt;/style&gt; 然后在创建AlertDialog.Builder时传进去123dialog=new AlertDialog.Builder(context,R.style.CustomDialog) .setView(view)... 再看效果 封装类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149import android.content.Context;import android.support.v7.app.AlertDialog;import android.view.Gravity;import android.view.LayoutInflater;import android.view.View;import android.widget.ImageView;import android.widget.TextView;import android.widget.Toast;import com.example.myframe.R;import com.wang.avi.AVLoadingIndicatorView;import java.util.Random;/** * Author：LvQingYang * Date：2017/8/18 * Email：biloba12345@gamil.com * Github：https://github.com/biloba123 *Blog：https://biloba123.github.io/ * Info： */public class MyToast &#123; private static Toast toast; private static AlertDialog dialog; //info toast public static void info(Context context ,String text, int duration)&#123; showToast(context, R.drawable.ic_info, text, duration); &#125; public static void info(Context context ,int textId, int duration)&#123; showToast(context, R.drawable.ic_info,context.getString(textId),duration); &#125; public static void info(Context context ,String text)&#123; showToast(context, R.drawable.ic_info, text, Toast.LENGTH_SHORT); &#125; public static void info(Context context ,int textId)&#123; showToast(context, R.drawable.ic_info,context.getString(textId),Toast.LENGTH_SHORT); &#125; //success public static void success(Context context ,String text, int duration)&#123; showToast(context, R.drawable.ic_success, text, duration); &#125; public static void success(Context context ,int textId, int duration)&#123; showToast(context, R.drawable.ic_success, context.getString(textId),duration); &#125; public static void success(Context context ,String text)&#123; showToast(context, R.drawable.ic_success, text, Toast.LENGTH_SHORT); &#125; public static void success(Context context ,int textId)&#123; showToast(context, R.drawable.ic_success, context.getString(textId),Toast.LENGTH_SHORT); &#125; //error public static void error(Context context ,String text, int duration)&#123; showToast(context, R.drawable.ic_error, text, duration); &#125; public static void error(Context context ,int textId, int duration)&#123; showToast(context, R.drawable.ic_error, context.getString(textId),duration); &#125; public static void error(Context context ,String text)&#123; showToast(context, R.drawable.ic_error, text, Toast.LENGTH_SHORT); &#125; public static void error(Context context ,int textId)&#123; showToast(context, R.drawable.ic_error, context.getString(textId),Toast.LENGTH_SHORT); &#125; //loading public static void loading(Context context ,String text)&#123; View view=LayoutInflater.from(context).inflate (R.layout.toast_loading,null); TextView tv=view.findViewById(R.id.tv); tv.setText(text); AVLoadingIndicatorView avl=view.findViewById(R.id.avl); avl.setIndicator(getIndicator(context)); avl.show(); dialog=new AlertDialog.Builder(context,R.style.CustomDialog) .setView(view) .setCancelable(false) .create(); dialog.show(); &#125; public static void loading(Context context ,int textId)&#123; loading(context, context.getString(textId)); &#125; //warning public static void warning(Context context ,String text, int duration)&#123; showToast(context, R.drawable.ic_warning, text, duration); &#125; public static void warning(Context context ,int textId, int duration)&#123; showToast(context, R.drawable.ic_warning, context.getString(textId),duration); &#125; public static void warning(Context context ,String text)&#123; showToast(context, R.drawable.ic_warning, text, Toast.LENGTH_SHORT); &#125; public static void warning(Context context ,int textId)&#123; showToast(context, R.drawable.ic_warning, context.getString(textId),Toast.LENGTH_SHORT); &#125; public static void cancel()&#123; if (toast != null) &#123; toast.cancel(); &#125; if (dialog != null) &#123; dialog.cancel(); &#125; &#125; static void showToast(Context context, int iconId, String text, int duration)&#123; if (toast != null) &#123; toast.cancel(); &#125; toast=Toast.makeText(context, text, duration); toast.setGravity(Gravity.CENTER,0,0); View v= LayoutInflater.from(context).inflate (R.layout.toast,null); ImageView ivIcon=v.findViewById(R.id.iv_icon); ivIcon.setImageResource(iconId); TextView tv=v.findViewById(R.id.tv); tv.setText(text); toast.setView(v); toast.show(); &#125; private static String getIndicator(Context context) &#123; String[] arrayOfString = context.getResources().getStringArray(R.array.arr_indicator); int i = new Random().nextInt(arrayOfString.length); return arrayOfString[i]; &#125;&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Toast</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Fragment中添加menu]]></title>
    <url>%2F2017%2F09%2F13%2FFragment%E4%B8%AD%E6%B7%BB%E5%8A%A0menu%2F</url>
    <content type="text"><![CDATA[Fragment是Android里面中一个非常灵巧的设计，它可以看做ui模块，由活动托管。熟练的使用它们能优雅的实现很复杂的界面，而且用它们编写UI界面，相对于用一个个Activity所消耗内存少得多，而且切换很流畅，可以参考知乎客户端。 但是，Fragment使用过程中会出现一些小问题，这里讲如何在Fragment中添加menu。我们都知道在活动中添加menu只用编写好menu，在onCreateOptionsMenu中加载，并在onOptionsItemSelected中处理点击事件就可以了，按照这个流程先试下 首先编写menu.xml12345678&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;menu xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&gt; &lt;item android:id=&quot;@+id/item_setting&quot; android:icon=&quot;@drawable/ic_settings&quot; android:title=&quot;@string/setting&quot; app:showAsAction=&quot;always&quot;/&gt;&lt;/menu&gt; 这里只添加一个设置的menu item 然后要加载menu需要toolbar或actionbar，这里分两种情况： 用Activity中actionbar或toolbar，在Fragment中不添加toolbar只需在Activity中初始化好标题栏（用toolbar时要调用setSupportActionBar），在fragment中 12345@Override public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) &#123; inflater.inflate(R.menu.menu_main,menu); super.onCreateOptionsMenu(menu, inflater); &#125; 去除Activity中标题栏，在Fragment中添加toolbar在fragment中初始化标题栏时要注意，fragment中没有setSupportActionBar方法，也就是在标题栏还是要交给托管其的活动来处理，标题栏最终设置到window上，代码如下 123456789101112131415/** * Fragment中初始化Toolbar * @param toolbar * @param title 标题 * @param isDisplayHomeAsUp 是否显示返回箭头 */ public void initToolbar(Toolbar toolbar, String title, boolean isDisplayHomeAsUp) &#123; AppCompatActivity appCompatActivity= (AppCompatActivity) getActivity(); appCompatActivity.setSupportActionBar(toolbar); ActionBar actionBar = appCompatActivity.getSupportActionBar(); if (actionBar != null) &#123; actionBar.setTitle(title); actionBar.setDisplayHomeAsUpEnabled(isDisplayHomeAsUp); &#125; &#125; 然后再调用onCreateOptionsMenu加载到toolbar上 运行一下，你会发现两种情况下menu都没加载出来。原来要在fragment中加载menu还需在其onCreate中加一句 setHasOptionsMenu(true)，用于让活动知道有menu要加载12345@Override public void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setHasOptionsMenu(true); &#125; 现在menu加载出来了 然后重写onOptionsItemSelected处理点击事件12345678910@Override public boolean onOptionsItemSelected(MenuItem item) &#123; switch (item.getItemId()) &#123; case R.id.item_setting: SettingActivity.start(getContext()); return true; default: return super.onOptionsItemSelected(item); &#125; &#125; 现在就大功告成了吗，然而运行后会发现无论怎么点击onOptionsItemSelected都没被调用。可以再android training中找到原因http://developer.android.com/guide/topics/ui/actionbar.html Note: If you added the menu item from a fragment, via the Fragment class’s onCreateOptionsMenu callback, then the system calls the respective onOptionsItemSelected() method for that fragment when the user selects one of the fragment’s items. However the activity gets a chance to handle the event first, so the system calls onOptionsItemSelected() on the activity before calling the same callback for the fragment. 也就是说在虽然在fragment中重写onOptionsItemSelected，但系统会在activity中先调用onOptionsItemSelected，而活动中默认都消耗了点击事件，fragment中因此无法处理点击。所以要先在托管碎片的活动中讲frament中处理的menu item返回false，让点击事件能穿到fragment的onOptionsItemSelected中123456789@Override public boolean onOptionsItemSelected(MenuItem paramMenuItem) &#123; switch (paramMenuItem.getItemId()) &#123; case R.id.item_setting: return false; default: return super.onOptionsItemSelected(paramMenuItem); &#125; &#125; 总结下要在fragment添加menu需要以下步骤： 在fragment的onCreate中添加一句 setHasOptionsMenu(true)； 如果用的是活动的标题栏，只需在onCreateOptionsMenu中加载menu；如果用Fragment自己的toolbar需要先用活动初始化toolbar，然后再onCreateOptionsMenu 在活动中重写onOptionsItemSelected，讲需要在fragment中处理的menu item直接返回false，再在fragment的onOptionsItemSelected中处理]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Fragment</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android样式开发完全指南]]></title>
    <url>%2F2017%2F09%2F11%2FAndroid%E6%A0%B7%E5%BC%8F%E5%BC%80%E5%8F%91%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[记得刚开始学Android时，看着自己完全用系统控件写出的不忍直视的界面，对于如何做出不一样的按钮，让它们在不同状态下有不一样的效果很是好奇。后来才知道了些shape，selector之类，但很长时间以来都没对样式开发做过全面的整理（主要因为懒…），所以有了这篇文章。 好了废话不多说，开始我们的样式开发之旅。因为整理了基本所有的样式，文章可能有点长，可以收藏下来看，当然看的时候也要自己试试效果，不然很容易过几天又忘记了，下次用的时候还要翻一遍。本文将按下面几个模块讲：1. shape：基础的形状定义2. selector：不同状态下的形状变化3. layer-list：多个形状层叠4. drawable：各式drawable和drawable动画5. View Animation：简单的视图动画6. Property Animation：更强大的属性动画7. style和theme 1. shapeshape用来定义基本的形状，一般项目的drawable目录下，布局中各view通过设置android:background属性来引用。 rectangle（矩形，默认的形状）新建一个drawable resource file，取名为bg_btn，来为按钮定义形状，根节点默认是selector，改成shape，shape下能设置多个特性，我们一个一个来看 solid：设置形状填充的颜色，只有android:color一个属性123&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;solid android:color=&quot;@android:color/holo_blue_dark&quot;/&gt;&lt;/shape&gt; 效果和直接设置view的background为颜色一样 padding：设置内容与形状边界的内间距，可分别设置左右上下的距离 android:left 左内间距 android:right 右内间距 android:top 上内间距 android:bottom 下内间距12345&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;solid android:color=&quot;@android:color/holo_blue_dark&quot;/&gt; &lt;padding android:top=&quot;16dp&quot; android:bottom=&quot;16dp&quot;/&gt;&lt;/shape&gt; 当然也和直接设置view的padding一样，不过当你的shape多次使用时，在shape中设置padding就免去为每个控件单独设置padding gradient：设置形状的渐变颜色，可以是线性渐变（linear，默认的渐变类型）辐射渐变（radial ，以圆形从圆形向周围渐变，android:gradientRadius也必须设置）扫描性渐变（sweep ,以一条水平线逆时针扫描渐变） android:type 渐变的类型 android:startColor 渐变开始的颜色 android:endColor 渐变结束的颜色 android:centerColor 渐变中间的颜色 android:angle 渐变的角度，线性渐变时才有效，必须是45的倍数，0表示从左到右，90表示从下到上 android:centerX 渐变中心的相对X坐标，放射渐变时才有效，在0.0到1.0之间，默认为0.5，表示在正中间 android:centerY 渐变中心的相对X坐标，放射渐变时才有效，在0.0到1.0之间，默认为0.5，表示在正中间 android:gradientRadius 渐变的半径，渐变类型为radial时使用 linear渐变效果123456&lt;gradient android:type=&quot;linear&quot; android:startColor=&quot;#18d1ff&quot; android:centerColor=&quot;#4953fd&quot; android:endColor=&quot;#5718bc&quot; android:angle=&quot;0&quot;/&gt;&lt;/shape&gt; 这里的渐变方向由android:angle来设置 radial渐变效果12345678&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;gradient android:type=&quot;radial&quot; android:startColor=&quot;#18d1ff&quot; android:centerColor=&quot;#4953fd&quot; android:endColor=&quot;#5718bc&quot; android:gradientRadius=&quot;160dp&quot;/&gt;&lt;/shape&gt; 渐变中心由(centerX, centerY)确定，比如我们都把它设为0 sweep渐变效果1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;gradient android:type=&quot;sweep&quot; android:startColor=&quot;#18d1ff&quot; android:centerColor=&quot;#4953fd&quot; android:endColor=&quot;#5718bc&quot;/&gt;&lt;/shape&gt; corners：设置圆角，只适用于rectangle类型 android:radius 圆角半径，会被下面每个具体的圆角属性覆盖 android:topLeftRadius 左上角的半径 android:topRightRadius 右上角的半径 android:bottomLeftRadius 左下角的半径 android:bottomRightRadius 右下角的半径1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;gradient android:startColor=&quot;#0564fe&quot; android:centerColor=&quot;#3b45ef&quot; android:endColor=&quot;#6f28e0&quot;/&gt; &lt;corners android:radius=&quot;24dp&quot;/&gt;&lt;/shape&gt; 分别设置topLeftRadius，topRightRadius，bottomLeftRadius stroke：设置描边，实线或虚线 android:color 描边的颜色 android:width 描边的宽度 android:dashWidth 设置虚线时的横线长度 android:dashGap 设置虚线时的横线之间的距离12345&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;stroke android:color=&quot;@android:color/darker_gray&quot; android:width=&quot;2dp&quot;/&gt;&lt;/shape&gt; 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;stroke android:color=&quot;@android:color/darker_gray&quot; android:width=&quot;2dp&quot; android:dashWidth=&quot;4dp&quot; android:dashGap=&quot;6dp&quot;/&gt;&lt;/shape&gt; oval（椭圆形，常用来画圆形）1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:shape=&quot;oval&quot;&gt; &lt;solid android:color=&quot;@android:color/holo_blue_dark&quot;/&gt; &lt;gradient android:type=&quot;radial&quot; android:startColor=&quot;#ffffff&quot; android:endColor=&quot;#a1a1a1&quot; android:gradientRadius=&quot;64dp&quot;/&gt; &lt;size android:height=&quot;128dp&quot; android:width=&quot;128dp&quot;/&gt;&lt;/shape&gt; 这里有个size节点，它是用来设置形状大小的，但一般不用它，比如我们现在把这个圆形设置给一个长宽不相等的控件，那效果还是椭圆，因为shape会被拉伸或压缩。不过我用到radial渐变，想让它从圆心刚好渐变到圆周，所以设置了size，并设置gradientRadius为size长宽的一半，这样无论设置给多大的控件都能正确显示 line（线形，画实线和虚线）12345678&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:shape=&quot;line&quot;&gt; &lt;stroke android:color=&quot;@android:color/darker_gray&quot; android:width=&quot;2dp&quot; android:dashWidth=&quot;4dp&quot; android:dashGap=&quot;6dp&quot;/&gt;&lt;/shape&gt; 画线一般用来分隔内容，上面我们画了一条虚线，把它设置给View，运行出来你发现怎么变成实线了，我要的虚线呢，这不是坑吗？？？ （╯‵□′）╯︵┴─┴原来要想显示出虚线要给View设置android:layerType，为”software”12345&lt;View android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;16dp&quot; android:layerType=&quot;software&quot; android:background=&quot;@drawable/bg_div&quot;/&gt; 画线时，有几点特性必须要知道的： 只能画水平线，画不了竖线； 线的高度是通过stroke的android:width属性设置的； size的android:height属性定义的是整个形状区域的高度； size的height必须大于stroke的width，否则，线无法显示； 线在整个形状区域中是居中显示的； 线左右两边会留有空白间距，线越粗，空白越大； 引用虚线的view需要添加属性android:layerType，值设为”software”，否则显示不了虚线。 ring（环形，可以画环形进度条）shape根元素有些属性只适用于ring类型，先来看看这些属性吧： android:innerRadius 内环的半径 android:innerRadiusRatio 浮点型，以环的宽度比率来表示内环的半径，默认为3，表示内环半径为环的宽度除以3，该值会被android:innerRadius覆盖 android:thickness 环的厚度 android:thicknessRatio 浮点型，以环的宽度比率来表示环的厚度，默认为9，表示环的厚度为环的宽度除以9，该值会被android:thickness覆盖 android:useLevel 一般为false，否则可能环形无法显示，只有作为LevelListDrawable使用时才设为true1234567891011121314&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:shape=&quot;ring&quot; android:innerRadiusRatio=&quot;3&quot; android:thicknessRatio=&quot;12&quot; android:useLevel=&quot;false&quot;&gt; &lt;gradient android:startColor=&quot;@android:color/white&quot; android:endColor=&quot;@android:color/holo_blue_dark&quot; android:type=&quot;sweep&quot; /&gt; &lt;stroke android:width=&quot;2dp&quot; android:color=&quot;@android:color/darker_gray&quot; /&gt;&lt;/shape&gt; 用innerRadiusRatio和thicknessRatio控制环内环和厚度占比是，两个倒数相加不能超过1/2，不然就不是环了，比如这里1/3 + 1/12 &lt; 1/2 但这进度条不会转叫什么进度条，下面会讲到如何让它转起来 2. selector上面我们讲了如何定义各种形状，并设置给控件，但开发中如果想让在不同状态下展示不同形状，比如按钮正常状态下一种形状，点击是另一种形状，这样对用户交互比较好，能让用户得到他操作后的反馈，这就要用到selector。 那首先有必要知道都有哪些状态： android:state_enabled: 设置触摸或点击事件是否可用状态，一般只在false时设置该属性，表示不可用状态 android:state_pressed: 设置是否按压状态，一般在true时设置该属性，表示已按压状态 android:state_selected: 设置是否选中状态，true表示已选中，false表示未选中 android:state_checked: 设置是否勾选状态，主要用于CheckBox和RadioButton，true表示已被勾选，false表示未被勾选 android:state_checkable: 设置勾选是否可用状态，类似state_enabled，只是–state_enabled会影响触摸或点击事件，而state_checkable影响勾选事件 android:state_focused: 设置是否获得焦点状态，true表示获得焦点，默认为false，表示未获得焦点 android:state_window_focused: 设置当前窗口是否获得焦点状态，true表示获得焦点，false表示未获得焦点，例如拉下通知栏或弹出对话框时，当前界面就会失去焦点 android:state_activated: 设置是否被激活状态，true表示被激活，false表示未激活，API Level 11及以上才支持，可通过代码调用控件的setActivated(boolean)方法设置是否激活该控件 android:state_hovered: 设置是否鼠标在上面滑动的状态，true表示鼠标在上面滑动，默认为false，API Level 14及以上才支持 一看到这么多状态是不是感觉头疼，不过平时用到比较多的也就 state_enabled，state_pressed，state_selected，输入框可能会用到state_focused 接下来，看看代码，以下是bg_btn_selector.xml的代码，用于按钮的背景，如果只是背景颜色的变化可以在res下新建一个color文件夹在里面创建selector作为color资源，如果是形状的变化则只能放到drawable下作为drawable资源，也是通过android:background设置给view： color\bg_btn_selector.xml1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;selector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;item android:state_enabled=&quot;false&quot; android:color=&quot;@android:color/darker_gray&quot;/&gt; &lt;item android:state_pressed=&quot;true&quot; android:color=&quot;@android:color/holo_blue_dark&quot;/&gt; &lt;item android:state_selected=&quot;true&quot; android:color=&quot;@android:color/holo_blue_dark&quot;/&gt; &lt;item android:color=&quot;@android:color/holo_blue_light&quot;/&gt;&lt;/selector&gt; android:color只能引用@color drawable\bg_btn_selector.xml1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;selector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;item android:state_enabled=&quot;false&quot; android:drawable=&quot;@drawable/bg_btn_disable&quot;/&gt; &lt;item android:state_pressed=&quot;true&quot; android:drawable=&quot;@drawable/bg_btn_pressed&quot;/&gt; &lt;item android:state_selected=&quot;true&quot; android:drawable=&quot;@drawable/bg_btn_selected&quot;/&gt; &lt;item android:drawable=&quot;@drawable/bg_btn_normal&quot;/&gt;&lt;/selector&gt; android:drawable指定的都是定义的shape，它除了引用@drawable资源，也可以引用@color颜色值 注意：状态是从上往下匹配的，如果匹配到一个item那它就将采用这个item，而不是采用最佳匹配的规则；所以设置默认的状态，一定要写在最后，如果写在前面，则后面所有的item都不会起作用了。 除此之外，selector标签下有两个比较常用的属性，会在状态改变时出现淡入淡出效果，但必须在API Level 11及以上才支持： android:enterFadeDuration 状态改变时，新状态展示时的淡入时间，以毫秒为单位 android:exitFadeDuration 状态改变时，旧状态消失时的淡出时间，以毫秒为单位 3. layer-listshape只能画出矩形，椭圆，线，环这些基本的形状，有时我们需要一些稍微复杂些的形状，一种解决方案是使用图片，但图片要准备不同尺寸以适应不同分辨率手机，太多图片资源会造成安装包过大，其实可以用layer-list来自己实现一些复杂形状 先来看看要实现效果 一个带阴影的button，未点击时阴影窄且深，按压时阴影变宽且颜色变浅。它首先是selector实现123456&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;selector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;item android:state_pressed=&quot;true&quot; android:drawable=&quot;@drawable/bg_btn_pressed&quot;/&gt; &lt;item android:state_selected=&quot;true&quot; android:drawable=&quot;@drawable/bg_btn_selected&quot;/&gt; &lt;item android:drawable=&quot;@drawable/bg_btn_normal&quot;/&gt;&lt;/selector&gt; 来看bg_btn_pressed，bg_btn_selected它们是一样的1234567891011121314151617181920&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;layer-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;!--灰色背景--&gt; &lt;item&gt; &lt;shape&gt; &lt;solid android:color=&quot;#c4c4c4&quot;/&gt; &lt;corners android:radius=&quot;12dp&quot;/&gt; &lt;/shape&gt; &lt;/item&gt; &lt;!--蓝色前景--&gt; &lt;item android:bottom=&quot;6dp&quot; android:right=&quot;6dp&quot;&gt; &lt;shape&gt; &lt;solid android:color=&quot;@android:color/holo_blue_dark&quot;/&gt; &lt;corners android:radius=&quot;12dp&quot;/&gt; &lt;/shape&gt; &lt;/item&gt;&lt;/layer-list&gt; layer-list作为根节点，也可以作为selector中item的子节点。layer-list可以添加多个item子节点，每个item子节点对应一个drawable资源，按照item从上到下的顺序叠加在一起，再通过设置每个item的偏移量就可以看到阴影效果了。layer-list的item可以通过下面四个属性设置偏移量： android:top 顶部的偏移量 android:bottom 底部的偏移量 android:left 左边的偏移量 android:right 右边的偏移量 这四个偏移量和控件的margin设置差不多，都是外间距的效果。如何不设置偏移量，前面的图层就完全挡住了后面的图层，从而也看不到后面的图层效果了。 然后是bg_btn_normal.xml1234567891011121314151617181920212223242526272829&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;layer-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;!--透明背景--&gt; &lt;item&gt; &lt;shape&gt; &lt;solid android:color=&quot;@android:color/transparent&quot;/&gt; &lt;corners android:radius=&quot;12dp&quot;/&gt; &lt;/shape&gt; &lt;/item&gt; &lt;!--灰色背景--&gt; &lt;item android:bottom=&quot;3dp&quot; android:right=&quot;3dp&quot;&gt; &lt;shape&gt; &lt;solid android:color=&quot;#bebebe&quot;/&gt; &lt;corners android:radius=&quot;12dp&quot;/&gt; &lt;/shape&gt; &lt;/item&gt; &lt;!--蓝色前景--&gt; &lt;item android:bottom=&quot;6dp&quot; android:right=&quot;6dp&quot;&gt; &lt;shape&gt; &lt;solid android:color=&quot;@android:color/holo_blue_light&quot;/&gt; &lt;corners android:radius=&quot;12dp&quot;/&gt; &lt;/shape&gt; &lt;/item&gt;&lt;/layer-list&gt; 第一个item是一个透明的shape，再在它上面加阴影效果，应为直接加阴影的话，normal状态时button的大小要比按压时大，看起来不太好。这里保证蓝色前景也就是按钮大小不变的情况下，按压时将透明shape那部分变成阴影，并且阴影变淡，这就达到效果了 4. drawable除了上面讲的shape,selector,layer-list，Android还有很多其他drawable资源 普通图片图片格式可以是png(最常用，推荐使用)、jpg、gif，用图片资源需要根据不同屏幕密度提供多张不同尺寸的图片： 密度分类 密度值范围 代表分辨率 图标尺寸 mdpi 120~160dpi 320x480px 48x48px hdpi 160~240dpi 480x800px 72x72px xhdpi 240~320dpi 720x1280px 96x96px xxhdpi 320~480dpi 1080x1920px 144x144px xxxhdpi 480~640dpi 1440x2560px 192x192px 一张图片一般需要提供5张不同比例的图片，切图的话可以用下面这个网站在线切http://icon.wuruihong.com/Android Studio中也可以用Image Assetl来导入符合Materical Design设计的应用常用图标 Vector Drawable普通图片需要提供多张不同尺寸的图片，这会加大安装包的大小。而从Android 5.0开始支持的Vector可以自动进行适配，不需要通过分辨率来设置不同的图片，可以大幅减少图像的体积，同样一张图，用Vector来实现，可能只有PNG的几十分之一 利用Android Studio的Vector Asset，可以非常方便的创建Vector图像，也可以直接通过本地的SVG图像来生成Vector图像 level-listlevel-list管理一组drawable，每个drawable设置一组level范围，最终会根据level值选取对应的drawable绘制出来。level-list通过添加item子标签来添加相应的drawable，其下的item只有三个属性： android:drawable 指定drawable资源，如果不设置该属性，也可以定义drawable类型的子标签 android:minLevel 该item的最小level值 android:maxLevel 该item的最大level值 用它来实现比如电量，信号强弱显示12345678910111213141516171819&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;level-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;item android:maxLevel=&quot;100&quot; android:minLevel=&quot;100&quot; android:drawable=&quot;@drawable/ic_battery_full_black_24dp&quot;/&gt; &lt;item android:maxLevel=&quot;99&quot; android:minLevel=&quot;90&quot; android:drawable=&quot;@drawable/ic_battery_90_black_24dp&quot;/&gt; &lt;item android:maxLevel=&quot;89&quot; android:minLevel=&quot;80&quot; android:drawable=&quot;@drawable/ic_battery_80_black_24dp&quot;/&gt; &lt;item android:maxLevel=&quot;79&quot; android:minLevel=&quot;60&quot; android:drawable=&quot;@drawable/ic_battery_60_black_24dp&quot;/&gt; &lt;item android:maxLevel=&quot;59&quot; android:minLevel=&quot;50&quot; android:drawable=&quot;@drawable/ic_battery_50_black_24dp&quot;/&gt; &lt;item android:maxLevel=&quot;49&quot; android:minLevel=&quot;30&quot; android:drawable=&quot;@drawable/ic_battery_30_black_24dp&quot;/&gt; &lt;item android:maxLevel=&quot;29&quot; android:minLevel=&quot;20&quot; android:drawable=&quot;@drawable/ic_battery_20_black_24dp&quot;/&gt; &lt;item android:maxLevel=&quot;19&quot; android:minLevel=&quot;0&quot; android:drawable=&quot;@drawable/ic_battery_alert_black_24dp&quot;/&gt;&lt;/level-list&gt; 设置给ImageView12345&lt;ImageView android:id=&quot;@+id/iv_battery&quot; android:layout_width=&quot;64dp&quot; android:layout_height=&quot;64dp&quot; android:src=&quot;@drawable/battery_level&quot;/&gt; 代码中通过getDrawable().setLevel(level)设置level，这里每点一下减少10%电量123level-=10;tvbattery.setText(level+&quot;&quot;);ivbattery.getDrawable().setLevel(level); item的匹配规则是从上到下的，当设置的level值与前面的item的level范围匹配，则采用。当从大到小排序下来，可以去掉每个item的android:maxLevel属性，比如上面，从小到大则可以去掉android:minLevel animation-listanimation-list可以将一系列drawable构建成帧动画，就是将一个个drawable，一帧一帧的播放。通过添加item子标签设置每一帧使用的drawable资源，以及每一帧持续的时间。123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;animation-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:oneshot=&quot;false&quot;&gt; &lt;item android:drawable=&quot;@drawable/ic_wifi_signal_0&quot; android:duration=&quot;1000&quot;/&gt; &lt;item android:drawable=&quot;@drawable/ic_wifi_signal_1&quot; android:duration=&quot;1000&quot;/&gt; &lt;item android:drawable=&quot;@drawable/ic_wifi_signal_2&quot; android:duration=&quot;1000&quot;/&gt; &lt;item android:drawable=&quot;@drawable/ic_wifi_signal_3&quot; android:duration=&quot;1000&quot;/&gt; &lt;item android:drawable=&quot;@drawable/ic_wifi_signal_4&quot; android:duration=&quot;1000&quot;/&gt;&lt;/animation-list&gt; android:oneshot属性设置是否循环播放，设为true时，只播放一轮就结束，设为false时，则会轮询播放。 android:duration属性设置该帧持续的时间，以毫秒数为单位。设置给ImageView，在代码中1((AnimationDrawable)iv.getDrawable()).start(); animation-list对应的Drawable类为AnimationDrawable，要让动画运行起来，需要主动调用AnimationDrawable的start()方法。另外，如果在Activity的onCreate()方法里直接调用start()方法会没有效果，因为view还没有初始化完成是播放不了动画的。 animated-rotateanimated-rotate会让drawable不停地做旋转动画（不用在代码中启动）animated-rotate可设置的属性只有四个： android:drawable 指定drawable资源，如果不设置该属性，也可以定义drawable类型的子标签 android:pivotX 旋转中心的X坐标 android:pivotY 旋转中心的Y坐标123456&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;animated-rotate xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:drawable=&quot;@drawable/bg_progressv&quot; android:pivotX=&quot;50%&quot; android:pivotY=&quot;50%&quot;&gt;&lt;/animated-rotate&gt; 注意：50%不能写成0.5, 它们是不同的意思，50%是相对于控件，0.5是相对于整个屏幕 ##5. View Animation未完]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>shape</tag>
        <tag>drawable</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MQTT--服务器搭建]]></title>
    <url>%2F2017%2F09%2F11%2FMQTT--%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[MQTT由IBM的Andy Stanford-Clark博士和Arcom的Arlen Nipper（现为Eurotech）于1999年发明。 MQTT代表MQ遥测传输。它是针对受限设备和低带宽，高延迟或不可靠网络设计的发布/订阅，非常简单和轻便的消息传递协议。设计原则是尽量减少网络带宽和设备资源需求，同时还要确保可靠性和一定程度的交付保证。这些原则还可以使协议成为连接设备新兴的“机器对机器”（M2M）或“物联网”世界的理想选择，以及带宽和电池电量非常高的移动应用。 前言最近要用arduino开发自主借还书的demo，通过mqtt协议发布数据到服务器，然后用APP订阅相应Topic接收数据，做相应处理。第一步先是搭建mqtt服务器，现在开源mqtt的broker比较多，最后还是选择了Apollo。当然如果不想自己搭建也可以用相应平台，比如阿里云的消息队列中有mqtt，以及物联网平台onenet等等（但是用他们要设置各种key和id，我试了能够连接，但publish始终不行，不知道是哪里设置错了） 搭建MQTT服务器 下载apollo下载地址http://activemq.apache.org/apollo/download.html 解压得到下面这些文件 bin下包含apollo和apollo.cmd两个文件 打开cmd进入到bin目录下，输入apollo.cmd create mybrokermybroker是服务器名字任意，服务器实例包含了所有的配置，运行时数据等，并且和一个服务器进程关联。（注意：这里需要java环境，没得要下载jdk，并配置环境变量） 完成后会多出一个mybroker文件夹 其中etc中包含相关配置文件，apollo.xml是配置服务器信息的文件，users.properties文件包含连接MQTT服务器时用到的用户名和密码，后面登录网页会介绍，可以修改原始的admin=password，可以接着换行添加新的用户名密码。 打开mybroker的bin目录，cmd进入到bin目录下，输入apollo-broker.cmd run开始运行，关闭cmd后会停止。或者可以install并run apollo-broker-service，让它长期在后台运行 在浏览器中输入http://127.0.0.1:61680/或https://127.0.0.1:61681/进入web管理页面，输入默认admin，password 队列和发布的Topic 连上的设备 配置页面 很多教程说到上面就没了，然后你试着用连接发现根本连不上，其实打开apollo.xml仔细看你会发现少配置了一个选项导致的，可以直接在web页面改 这两处取消注释就可以连接上了，修改后保存会重新载入配置文件 其他在apollo.xml中 上面两行是web管理登入链接，下面第一个是tcp方式连接是端口，可以自行更改，比如一般默认1883端口]]></content>
      <categories>
        <category>Arduino</category>
      </categories>
      <tags>
        <tag>Arduino</tag>
        <tag>MQTT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MQTT--NodeMCU及MQTT接发消息体验]]></title>
    <url>%2F2017%2F09%2F11%2FMQTT--NodeMCU%E5%8F%8AMQTT%E6%8E%A5%E5%8F%91%E6%B6%88%E6%81%AF%E4%BD%93%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[使用MQTT先要有一个MQTT服务器，具体如何搭建可以看上一篇文章http://www.jianshu.com/p/e11a47f1e53c 这一篇主要讲下NodeMCU的使用，以及MQTT介绍和如何接发消息 NodeMCUESP8266介绍介绍NodeMCU前需要先了解ESP8266，它是一个完整自称体系的WiFi网络解决方案，能独立运行也可为从部件连接单片机运行 具有以下特点： 超小尺寸 低功耗 内置TCP/IP协议 可编程 低成本 NodeMCU介绍NodeMCU是一款基于ESP8266模块的开源硬件，符合Arduino框架。同时可使用Node.js编程 WiFi测试先要安装Arduino IDE For ESP8266Arduino IDE For ESP8266是根据Arduino修改的专门烧写ESP8266开发板的IDE。在装好Arduino IDE后： 打开Arduino 文件-&gt;首选项，在 附加开发管理网站 中填入http://arduino.esp8266.com/stable/package_esp8266com_index.json，然后点击确定保存 重启IDE后，打开 工具-&gt;开发板-&gt;开发板管理器；搜索ESP8266，选择esp 8266 by ESP8266 Community安装 下载完成后可以在开发板选项中看到ESP8266 Module,以及NodeMCU等可选开发板 将NodeMCU通过usb连接到电脑，在工具下选择相应配置 波特率越大烧录程序速度越快但有可能出错端口选择NodeMCU对应端口，如果没看到端口，那是驱动没有装，装驱动可以看这里http://www.arduino.cn/thread-1008-1-1.html 打开示例选择ESP8266WiFi中的WiFiScan 烧到板子上打开窗口监视器可以看到扫描出来的附近热点 MQTTMQTT介绍消息队列遥测传输(MQTT)是IBM开发的即时通讯协议，为计算能力有限且工作在低带宽、不可靠网络的传感器或控制设备而设计。比如对于移动开发，它可以用于消息推送，即时通讯等等 特性： 发布/订阅的消息模式，提供一对多的消息发布 使用TCP/IP提供网络连接 有三种消息发布服务质量，至多一次，至少一次，只有一次 传输小、开销小 LastWill通知中断机制 MQTT原理介绍 客户端：发布者(Publish)、订阅者(SubScribe)，客户端有ID,ID冲突会挤掉先连接客户端。 服务器端：代理(Broker) 消息：主题(Topic)+负载(payload) 举个场景为例： QQ用户2(账号QQ1000)向QQ用户1(QQ9999)发送消息“Hello World”.发送者：QQ用户2订阅者：QQ用户1消息：QQ9999+”Hello World”. 消息发送至服务器，服务器查找QQ9999对应的用户后，发送信息给QQ用户2. MQTT ESP8266库菜单“项目”-“加载库”-“管理库”，搜索安装“PubSubClient” PubSubClient有一些示例可以打开mqtt_esp8266看下 MQTT接发消息体验这里做两个示例1. NodeMCU发布消息：光照强度传感器测得环境光照强度发布到服务器，手机订阅该Topic接收光强信息 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;ESP8266WiFi.h&gt;#include &lt;PubSubClient.h&gt;int pinLED = D2;const char* ssid = &quot;********&quot;;//连接的路由器的名字const char* password = &quot;********&quot;;//连接的路由器的密码const char* mqtt_server = &quot;********&quot;;//服务器的地址 const int port=****;//服务器端口号WiFiClient espClient;PubSubClient client(espClient);int light=255;void setup_wifi() &#123;//自动连WIFI接入网络 delay(10); WiFi.begin(ssid, password); while (WiFi.status() != WL_CONNECTED) &#123; delay(500); Serial.print(&quot;...&quot;); &#125;&#125;void callback(char* topic, byte* payload, unsigned int length) &#123;//用于接收数据 int l=0; int p=1; for (int i = length-1; i &gt;=0; i--) &#123; l+=(int)((char)payload[i]-&apos;0&apos;)*p; p*=10; &#125; light=l; Serial.println(l);//换行&#125;void reconnect() &#123;//等待，直到连接上服务器 while (!client.connected()) &#123;//如果没有连接上 if (client.connect(&quot;biloba&quot;)+random(999999999)) &#123;//接入时的用户名，尽量取一个很不常用的用户名 client.subscribe(&quot;LED&quot;);//接收外来的数据时的intopic &#125; else &#123; Serial.print(&quot;failed, rc=&quot;);//连接失败 Serial.print(client.state());//重新连接 Serial.println(&quot; try again in 5 seconds&quot;);//延时5秒后重新连接 delay(5000); &#125; &#125;&#125;void setup() &#123;//初始化程序，只运行一遍 Serial.begin(9600);//设置串口波特率（与烧写用波特率不是一个概念） setup_wifi();//自动连WIFI接入网络 client.setServer(mqtt_server, port);//端口号 client.setCallback(callback); //用于接收服务器接收的数据&#125;void loop() &#123;//主循环 reconnect();//确保连上服务器，否则一直等待。 client.loop();//MUC接收数据的主循环函数。 analogWrite(pinLED,light);&#125; 先使用ESP8266WiFi库的方法连接一个wifi，连接成功后loop中获取光强并转换为json格式，发布到light的Topic主题下，可以打开服务器web管理页面，可以在Topic找到它 接着试着用手机app订阅接收传感器发的消息（具体Android端如何实现下篇文章会讲到），在google play中下载一个myMqtt的APP，不方便的可以在这里下http://pan.baidu.com/s/1slE0cw9 打开APP，在setting中设置你服务器ip，端口等保存，如果顶部显示绿色表明连接成功，在Subscribe中订阅light主题，返回到Dashboard就能实时收到消息 1. NodeMCU接收消息：连接一个led灯，用手机APP控制灯的亮度1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;ESP8266WiFi.h&gt;#include &lt;PubSubClient.h&gt;#include &lt;math.h&gt;int pinLED = D2;const char* ssid = &quot;********&quot;;//连接的路由器的名字const char* password = &quot;********&quot;;//连接的路由器的密码const char* mqtt_server = &quot;********&quot;;//服务器的地址 const int port=****;//服务器端口号WiFiClient espClient;PubSubClient client(espClient);int light=1024;//led的亮度值void setup_wifi() &#123;//自动连WIFI接入网络 delay(10); WiFi.begin(ssid, password); while (WiFi.status() != WL_CONNECTED) &#123; delay(500); Serial.print(&quot;...&quot;); &#125;&#125;void callback(char* topic, byte* payload, unsigned int length) &#123;//用于接收数据 //将char* 转换为int int l=0; int p=1; for (int i = length-1; i &gt;=0; i--) &#123; l+=(int)((char)payload[i]-&apos;0&apos;)*p; p*=10; &#125; light=l;//赋值给light Serial.println(l);&#125;void reconnect() &#123;//等待，直到连接上服务器 while (!client.connected()) &#123;//如果没有连接上 if (client.connect(&quot;biloba&quot;)+random(999999999)) &#123;//接入时的用户名，尽量取一个很不常用的用户名 client.subscribe(&quot;LED&quot;);//接收外来的数据时的intopic &#125; else &#123; Serial.print(&quot;failed, rc=&quot;);//连接失败 Serial.print(client.state());//重新连接 Serial.println(&quot; try again in 5 seconds&quot;);//延时5秒后重新连接 delay(5000); &#125; &#125;&#125;void setup() &#123;//初始化程序，只运行一遍 Serial.begin(9600);//设置串口波特率（与烧写用波特率不是一个概念） setup_wifi();//自动连WIFI接入网络 client.setServer(mqtt_server, port);//端口号 client.setCallback(callback); //用于接收服务器接收的数据&#125;void loop() &#123;//主循环 reconnect();//确保连上服务器，否则一直等待。 client.loop();//MUC接收数据的主循环函数。 analogWrite(pinLED,light);//设置led亮度&#125; 代码跟上面没太大区别，只不过这里不发信息了，而接收LED Topic的信息，接收到转换为int设置为灯的亮度，这样就实现远程app控灯。打开myMqtt的publish，输入Topic为LED，Message为灯的亮度（0-1024），可以实时控制灯]]></content>
      <categories>
        <category>Arduino</category>
      </categories>
      <tags>
        <tag>Arduino</tag>
        <tag>MQTT</tag>
        <tag>NodeMCU</tag>
      </tags>
  </entry>
</search>
