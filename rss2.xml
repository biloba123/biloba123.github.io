<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>吕晴阳</title>
    <link>http://yoursite.com/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>走过的人说树枝长了，走过的人说树枝在长</description>
    <pubDate>Fri, 27 Oct 2017 13:31:44 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>Android Canvas的drawText()和文字居中方案</title>
      <link>http://yoursite.com/2017/10/27/Android%20Canvas%E7%9A%84drawText()%E5%92%8C%E6%96%87%E5%AD%97%E5%B1%85%E4%B8%AD%E6%96%B9%E6%A1%88/</link>
      <guid>http://yoursite.com/2017/10/27/Android%20Canvas%E7%9A%84drawText()%E5%92%8C%E6%96%87%E5%AD%97%E5%B1%85%E4%B8%AD%E6%96%B9%E6%A1%88/</guid>
      <pubDate>Fri, 27 Oct 2017 13:29:52 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;自定义View是绘制文本有三类方法&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div
        
      
      </description>
      
      <content:encoded><![CDATA[<p>自定义View是绘制文本有三类方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">// 第一类</div><div class="line">public void drawText (String text, float x, float y, Paint paint)</div><div class="line">public void drawText (String text, int start, int end, float x, float y, Paint paint)</div><div class="line">public void drawText (CharSequence text, int start, int end, float x, float y, Paint paint)</div><div class="line">public void drawText (char[] text, int index, int count, float x, float y, Paint paint)</div><div class="line"></div><div class="line">&lt;!--more--&gt;</div><div class="line"></div><div class="line">// 第二类</div><div class="line">public void drawPosText (String text, float[] pos, Paint paint)</div><div class="line">public void drawPosText (char[] text, int index, int count, float[] pos, Paint paint)</div><div class="line"></div><div class="line">// 第三类</div><div class="line">public void drawTextOnPath (String text, Path path, float hOffset, float vOffset, Paint paint)</div><div class="line">public void drawTextOnPath (char[] text, int index, int count, Path path, float hOffset, float vOffset, Paint paint)</div></pre></td></tr></table></figure></p><p>其中drawText()最常用，drawPosText ()是根据一个个坐标点指定文字位置，drawTextOnPath ()是根据路径绘制。但drawText()的x,y参数是干嘛的呢？</p><p>先来测试下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">Paint paint=new Paint();</div><div class="line">        paint.setStyle(Paint.Style.FILL);</div><div class="line">        paint.setStrokeWidth(12);</div><div class="line">        paint.setTextSize(100);</div><div class="line"></div><div class="line">        String text=&quot;测试：my text&quot;;</div><div class="line">        canvas.drawText(text, 200, 400, paint);</div><div class="line"></div><div class="line">        //画两条线标记位置</div><div class="line">        paint.setStrokeWidth(4);</div><div class="line">        paint.setColor(Color.RED);</div><div class="line">        canvas.drawLine(0, 400, 2000, 400, paint);</div><div class="line">        paint.setColor(Color.BLUE);</div><div class="line">        canvas.drawLine(200, 0, 200, 2000, paint);</div></pre></td></tr></table></figure></p><p><img src="http://upload-images.jianshu.io/upload_images/5734256-034ce9861f52b1d4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="左对齐-left"></p><p>可以看到，x,y并不是指定文字的中点位置，并且x,y与文字对齐方式有关（通过setTextAlign()指定，默认为left）</p><p><img src="http://upload-images.jianshu.io/upload_images/5734256-a6c0fc7234bbf914.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="居中对齐-center"></p><p><img src="http://upload-images.jianshu.io/upload_images/5734256-aa80878af37cf346.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="右对齐-right"></p><p>（为了使文字完整，上面调整了下x,y的值）</p><p>从上面三种情况得出结论，x所对应的竖线：</p><ul><li>左对齐 — 文字的左边界</li><li>居中对齐 — 文字的中心位置</li><li>右对齐 — 文字的左边界</li></ul><p>y对应的横线并不是文字的下边界，而是基准线Baseline</p><p>看下面这张图</p><p><img src="http://upload-images.jianshu.io/upload_images/5734256-512082b482008a3e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>红色的Baseline是基准线，紫色的Top是文字的最顶部，也就是在drawText()中指定的x所对应，橙色的Bottom是文字的底部。<br>拿这些值如何获取呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Paint.FontMetrics fontMetrics=paint.getFontMetrics();</div><div class="line">        fontMetrics.top</div><div class="line">        fontMetrics.ascent</div><div class="line">        fontMetrics.descent</div><div class="line">        fontMetrics.bottom</div></pre></td></tr></table></figure></p><p>记得要在设置完Paint的文字大小，宽度之类属性后再获取FontMetrics，<br>baseline对应对应值为0，在它下面的descent和bottom值为正，top和ascent为负。那文字的高度为<code>bottom - top</code></p><p><img src="http://upload-images.jianshu.io/upload_images/5734256-64f218ab8594bb3a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>所以，实际绘制的时候取决于基线上一个点来绘制文字,而这个点有三种分别对应为left,center,right</p><p><img src="http://upload-images.jianshu.io/upload_images/5734256-1b709c4384247865.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>好啦，把drawText()中x,y参数讲清楚后实现文字居中就很容易了<br>直接上代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">//矩形背景</div><div class="line">        Paint bgRect=new Paint();</div><div class="line">        bgRect.setStyle(Paint.Style.FILL);</div><div class="line">        bgRect.setColor(Color.YELLOW);</div><div class="line">        RectF rectF=new RectF(200, 200, 800, 600);</div><div class="line">        canvas.drawRect(rectF, bgRect);</div><div class="line"></div><div class="line">        Paint textPaint=new Paint();</div><div class="line">        textPaint.setStyle(Paint.Style.FILL);</div><div class="line">        textPaint.setStrokeWidth(8);</div><div class="line">        textPaint.setTextSize(50);</div><div class="line">        textPaint.setTextAlign(Paint.Align.CENTER);</div><div class="line"></div><div class="line">        String text=&quot;测试：my text&quot;;</div><div class="line">        //计算baseline</div><div class="line">        Paint.FontMetrics fontMetrics=textPaint.getFontMetrics();</div><div class="line">        float distance=(fontMetrics.bottom - fontMetrics.top)/2 - fontMetrics.bottom;</div><div class="line">        float baseline=rectF.centerY()+distance;</div><div class="line">        canvas.drawText(text, rectF.centerX(), baseline, textPaint);</div></pre></td></tr></table></figure></p><p>效果</p><p><img src="http://upload-images.jianshu.io/upload_images/5734256-8bf933b5d441a516.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>将对齐方式设置为center，那要让文字居中显示，x值就为矩形中心x值，y值也就是baseline的计算看下图</p><p><img src="http://upload-images.jianshu.io/upload_images/5734256-3c9cf9b18ff4e8db.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><code>y = 矩形中心y值 + 矩形中心与基线的距离</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">距离 = 文字高度的一半 - 基线到文字底部的距离（也就是bottom）</div><div class="line">     = (fontMetrics.bottom - fontMetrics.top)/2 - fontMetrics.bottom</div></pre></td></tr></table></figure></p>]]></content:encoded>
      
      <comments>http://yoursite.com/2017/10/27/Android%20Canvas%E7%9A%84drawText()%E5%92%8C%E6%96%87%E5%AD%97%E5%B1%85%E4%B8%AD%E6%96%B9%E6%A1%88/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Java反射机制</title>
      <link>http://yoursite.com/2017/10/27/Java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/</link>
      <guid>http://yoursite.com/2017/10/27/Java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/</guid>
      <pubDate>Fri, 27 Oct 2017 13:27:44 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;一、-反射概述&quot;&gt;&lt;a href=&quot;#一、-反射概述&quot; class=&quot;headerlink&quot; title=&quot;一、 反射概述&quot;&gt;&lt;/a&gt;一、 反射概述&lt;/h2&gt;&lt;h3 id=&quot;1-1-反射机制定义&quot;&gt;&lt;a href=&quot;#1-1-反射机制定义&quot; class=&quot;headerlink&quot; title=&quot;1.1 反射机制定义&quot;&gt;&lt;/a&gt;1.1 反射机制定义&lt;/h3&gt;&lt;p&gt;Java反射机制是在运行状态中，对于任意一个类，都能够知道这个类中的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。&lt;/p&gt;
&lt;h3 id=&quot;1-2-反射机制的功能&quot;&gt;&lt;a href=&quot;#1-2-反射机制的功能&quot; class=&quot;headerlink&quot; title=&quot;1.2 反射机制的功能&quot;&gt;&lt;/a&gt;1.2 反射机制的功能&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;在运行时判断任意一个对象所属的类。&lt;/li&gt;
&lt;li&gt;在运行时构造任意一个类的对象。&lt;/li&gt;
&lt;li&gt;在运行时判断任意一个类所具有的成员变量和方法。&lt;/li&gt;
&lt;li&gt;在运行时调用任意一个对象的方法。&lt;/li&gt;
&lt;li&gt;生成动态代理。&lt;/li&gt;
&lt;/ul&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="一、-反射概述"><a href="#一、-反射概述" class="headerlink" title="一、 反射概述"></a>一、 反射概述</h2><h3 id="1-1-反射机制定义"><a href="#1-1-反射机制定义" class="headerlink" title="1.1 反射机制定义"></a>1.1 反射机制定义</h3><p>Java反射机制是在运行状态中，对于任意一个类，都能够知道这个类中的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。</p><h3 id="1-2-反射机制的功能"><a href="#1-2-反射机制的功能" class="headerlink" title="1.2 反射机制的功能"></a>1.2 反射机制的功能</h3><ul><li>在运行时判断任意一个对象所属的类。</li><li>在运行时构造任意一个类的对象。</li><li>在运行时判断任意一个类所具有的成员变量和方法。</li><li>在运行时调用任意一个对象的方法。</li><li>生成动态代理。</li></ul><a id="more"></a><h2 id="二、-通过Java反射查看类信息"><a href="#二、-通过Java反射查看类信息" class="headerlink" title="二、 通过Java反射查看类信息"></a>二、 通过Java反射查看类信息</h2><h3 id="2-1-获得Class对象"><a href="#2-1-获得Class对象" class="headerlink" title="2.1 获得Class对象"></a>2.1 获得Class对象</h3><p>每个类被加载之后，系统就会为该类生成一个对应的Class对象。通过该Class对象就可以访问到JVM中的这个类。</p><p>获取方式：</p><ol><li>使用Class类的forName(String clazzName)静态方法。该方法需要传入字符串参数，该字符串参数的值是某个类的全限定名（必须添加完整包名）。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Class class1 = Class.forName(&quot;com.com.lvqingyang.interview.Person&quot;);</div></pre></td></tr></table></figure><ol><li>调用某个类的class属性来获取该类对应的Class对象。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">class1 = Person.class;</div></pre></td></tr></table></figure><ol><li>调用某个对象的getClass()方法。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Person person = new Person();</div><div class="line">Class&lt;?&gt; class1 = person.getClass();</div></pre></td></tr></table></figure><h3 id="2-2-获取class对象的属性、方法、构造函数等"><a href="#2-2-获取class对象的属性、方法、构造函数等" class="headerlink" title="2.2 获取class对象的属性、方法、构造函数等"></a>2.2 获取class对象的属性、方法、构造函数等</h3><ol><li>获取class对象的成员变量</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Field[] allFields = class1.getDeclaredFields();//获取class对象的所有属性</div><div class="line">Field[] publicFields = class1.getFields();//获取class对象的public属性</div><div class="line">Field ageField = class1.getDeclaredField(&quot;age&quot;);//获取class指定属性</div><div class="line">Field desField = class1.getField(&quot;des&quot;);//获取class指定的public属性</div></pre></td></tr></table></figure><ol><li>获取class对象的方法</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Method[] methods = class1.getDeclaredMethods();//获取class对象的所有声明方法</div><div class="line">Method[] allMethods = class1.getMethods();//获取class对象的所有public方法 包括父类的方法</div><div class="line">Method method = class1.getMethod(&quot;info&quot;, String.class);//返回次Class对象对应类的、带指定形参列表的public方法</div><div class="line">Method declaredMethod = class1.getDeclaredMethod(&quot;info&quot;, String.class);//返回次Class对象对应类的、带指定形参列表的方法</div></pre></td></tr></table></figure><ol><li>获取class对象的构造函数</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Constructor&lt;?&gt;[] allConstructors = class1.getDeclaredConstructors();//获取class对象的所有声明构造函数</div><div class="line">Constructor&lt;?&gt;[] publicConstructors = class1.getConstructors();//获取class对象public构造函数</div><div class="line">Constructor&lt;?&gt; constructor = class1.getDeclaredConstructor(String.class);//获取指定声明构造函数</div><div class="line">Constructor publicConstructor = class1.getConstructor(String.class);//获取指定声明的public构造函数</div></pre></td></tr></table></figure><ol><li>其他方法</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Annotation[] annotations = (Annotation[]) class1.getAnnotations();//获取class对象的所有注解</div><div class="line">Annotation annotation = (Annotation) class1.getAnnotation(Deprecated.class);//获取class对象指定注解</div><div class="line">Type genericSuperclass = class1.getGenericSuperclass();//获取class对象的直接超类的 Type</div><div class="line">Type[] interfaceTypes = class1.getGenericInterfaces();//获取class对象的所有接口的type集合</div></pre></td></tr></table></figure><h2 id="三、通过Java反射生成并操作对象"><a href="#三、通过Java反射生成并操作对象" class="headerlink" title="三、通过Java反射生成并操作对象"></a>三、通过Java反射生成并操作对象</h2><h3 id="3-1-生成类的实例对象"><a href="#3-1-生成类的实例对象" class="headerlink" title="3.1 生成类的实例对象"></a>3.1 生成类的实例对象</h3><ul><li>使用Class对象的newInstance()方法来创建该Class对象对应类的实例。这种方式要求该Class对象的对应类有默认构造器，而执行newInstance()方法时实际上是利用默认构造器来创建该类的实例。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Object obj = class1.newInstance();</div></pre></td></tr></table></figure><ul><li>先使用Class对象获取指定的Constructor对象，再调用Constructor对象的newInstance()方法来创建该Class对象对应类的实例。通过这种方式可以选择使用指定的构造器来创建实例。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Constructor&lt;?&gt; constructor = class1.getDeclaredConstructor(String.class);//获取指定声明构造函数</div><div class="line">obj = constructor.newInstance(&quot;hello&quot;);</div></pre></td></tr></table></figure><h3 id="3-2-调用类的方法"><a href="#3-2-调用类的方法" class="headerlink" title="3.2 调用类的方法"></a>3.2 调用类的方法</h3><p>调用Method对象中的 Object invoke(Object obj, Object… args) 方法。第一个参数对应调用该方法的实例对象，第二个参数对应该方法的参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// 生成新的对象：用newInstance()方法</div><div class="line">Object obj = class1.newInstance();</div><div class="line">//首先需要获得与该方法对应的Method对象</div><div class="line">Method method = class1.getDeclaredMethod(&quot;setAge&quot;, int.class);</div><div class="line">//调用指定的函数并传递参数</div><div class="line">method.invoke(obj, 28);</div></pre></td></tr></table></figure><p>要调用某个对象的private方法，则要先调用Method对象的<code>setAccessible(boolean flag)</code>方法。值为true，指示该Method在使用时应该取消Java语言的访问权限检查；false要实施Java语言的访问权限检查</p><h3 id="3-3-访问成员变量值"><a href="#3-3-访问成员变量值" class="headerlink" title="3.3 访问成员变量值"></a>3.3 访问成员变量值</h3><ul><li><p>读取成员变量值</p><p>基本变量：getXXX(Object obj)  获取obj对象的该成员变量的值，XXX对应8种基本类型。</p><p>引用类型：get(Object obj) </p></li><li><p>设置成员变量值</p><p>基本变量：setXXX(Object obj, XXX val)  设置obj对象的该成员变量的值，XXX对应8种基本类型。</p><p>引用类型：setXXX(Object obj, Object val)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//生成新的对象：用newInstance()方法</div><div class="line">Object obj = class1.newInstance();</div><div class="line">//获取age成员变量</div><div class="line">Field field = class1.getField(&quot;age&quot;);</div><div class="line">//将obj对象的age的值设置为10</div><div class="line">field.setInt(obj, 10);</div><div class="line">//获取obj对象的age的值</div><div class="line">field.getInt(obj);</div></pre></td></tr></table></figure><p>​</p></li></ul>]]></content:encoded>
      
      <comments>http://yoursite.com/2017/10/27/Java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/#disqus_thread</comments>
    </item>
    
    <item>
      <title>你要了解的Android Studio 3.0新特新</title>
      <link>http://yoursite.com/2017/10/27/%E4%BD%A0%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84Android%20Studio%203.0%E6%96%B0%E7%89%B9%E6%96%B0/</link>
      <guid>http://yoursite.com/2017/10/27/%E4%BD%A0%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84Android%20Studio%203.0%E6%96%B0%E7%89%B9%E6%96%B0/</guid>
      <pubDate>Fri, 27 Oct 2017 13:25:47 GMT</pubDate>
      <description>
      
        &lt;p&gt;Android Studio 3.0稳定版刚发布，它相对于2.3版本有较大的优化和新功能，变得更加强大。那来看看都有哪些：&lt;/p&gt;
&lt;p&gt;（还没更新的去官网&lt;a href=&quot;https://developer.android.google.cn/studio/index.html下载更新）&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://developer.android.google.cn/studio/index.html下载更新）&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;Android-Plugin-for-Gradle-3-0-0&quot;&gt;&lt;a href=&quot;#Android-Plugin-for-Gradle-3-0-0&quot; class=&quot;headerlink&quot; title=&quot;Android Plugin for Gradle 3.0.0&quot;&gt;&lt;/a&gt;Android Plugin for Gradle 3.0.0&lt;/h2&gt;&lt;h3 id=&quot;1-升级插件&quot;&gt;&lt;a href=&quot;#1-升级插件&quot; class=&quot;headerlink&quot; title=&quot;1. 升级插件&quot;&gt;&lt;/a&gt;1. 升级插件&lt;/h3&gt;&lt;p&gt;在build.gradle文件中更改&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>Android Studio 3.0稳定版刚发布，它相对于2.3版本有较大的优化和新功能，变得更加强大。那来看看都有哪些：</p><p>（还没更新的去官网<a href="https://developer.android.google.cn/studio/index.html下载更新）" target="_blank" rel="external">https://developer.android.google.cn/studio/index.html下载更新）</a></p><h2 id="Android-Plugin-for-Gradle-3-0-0"><a href="#Android-Plugin-for-Gradle-3-0-0" class="headerlink" title="Android Plugin for Gradle 3.0.0"></a>Android Plugin for Gradle 3.0.0</h2><h3 id="1-升级插件"><a href="#1-升级插件" class="headerlink" title="1. 升级插件"></a>1. 升级插件</h3><p>在build.gradle文件中更改</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">buildscript &#123;</div><div class="line">    repositories &#123;</div><div class="line">        // Gradle 4.1 and higher include support for Google&apos;s Maven repo using</div><div class="line">        // the google() method. And you need to include this repo to download</div><div class="line">        // Android plugin 3.0.0 or higher.</div><div class="line">        google()</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line">    dependencies &#123;</div><div class="line">        classpath &apos;com.android.tools.build:gradle:3.0.0&apos;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>然后进行同步，这个过程有点慢，并且需要科学上网。完成后对应gradle也更新到4.1</p><p>gradle-wrapper.properties</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">distributionUrl=https\://services.gradle.org/distributions/gradle-4.1-all.zip</div></pre></td></tr></table></figure><h3 id="2-新版本特性"><a href="#2-新版本特性" class="headerlink" title="2. 新版本特性"></a>2. 新版本特性</h3><p>Android Plugin for Gradle 3.0.0主要提高了包含大量模块的项目的构建性能。在这些这些大型项目使用新插件可以更快的构建配置时间，对代码或资源应用简单的更改时，更快的增量构建时间。</p><p>除此之外还包含以下内容：</p><ul><li>支持Android 8.0。</li><li>支持基于语言资源构建单独的APK。</li><li>支持Java 8库和Java 8语言功能（不用像之前使用Jack编译器）。</li><li>支持Android测试支持库1.0（Android测试实用程序和 Android测试协调器。</li><li>改进了ndk-build和cmake构建速度。</li><li>改进了渐变同步速度。</li><li>AAPT2默认启用。</li><li>使用<code>ndkCompile</code>更受限制，应该转而使用CMake或ndk-build来编译您要将其打包到APK中的本地代码。</li></ul><h2 id="Kotlin支持"><a href="#Kotlin支持" class="headerlink" title="Kotlin支持"></a>Kotlin支持</h2><p>自从I/O大会宣布将Kotlin作为Android指定开发语言，Kotlin就变得很火。3.0也对Kotlin提供了完全的支持</p><ul><li>将Java文件转换为Kotlin<br><img src="http://upload-images.jianshu.io/upload_images/5734256-e92ae670d89a94a4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640" alt=""></li></ul><p>便能将Java代码转换为Kotlin，不过转换后有些不正确的地方需要自行修改下</p><p><img src="http://upload-images.jianshu.io/upload_images/5734256-229431269d56f108.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640" alt=""></p><ul><li>直接添加Kotlin文件</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/5734256-5289b6496df43e6f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>Activity等也支持直接添加Kotlin的模板</p><p><img src="http://upload-images.jianshu.io/upload_images/5734256-82b25276e3308de7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>默认情况下，Kotlin和Java文件都会放在<code>src/main/java</code>目录下，如果你想把它们分开来，可以把Kotlin放在<code>src/main/kotlin</code>，并在sourceSets中添加以下配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">android &#123;</div><div class="line">   sourceSets &#123;</div><div class="line">       main.java.srcDirs += &apos;src/main/kotlin&apos;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="Android-Profiler"><a href="#Android-Profiler" class="headerlink" title="Android Profiler"></a>Android Profiler</h2><p>新的Android Profiler 取代了Android监视器工具，并提供了一套新的工具来实时测量应用程序的CPU，内存和网络使用情况。<br>点击工具栏的图标开启</p><p><img src="http://upload-images.jianshu.io/upload_images/5734256-f17dc71d486ee594.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><img src="http://upload-images.jianshu.io/upload_images/5734256-3acbb13ee03cb4f0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>从Android Profiler的概述时间轴上，单击CPU，MEMORY或 NETWORK时间线以访问相应的分析器工具。</p><h3 id="1-CPU-Profiler"><a href="#1-CPU-Profiler" class="headerlink" title="1. CPU Profiler"></a>1. CPU Profiler</h3><p>CPU Profiler可帮助你通过触发示例或仪表化的CPU跟踪来分析应用程序的CPU线程使用情况。可以使用各种数据视图和过滤器来解决CPU性能问题。<br>具体使用<a href="https://developer.android.com/studio/profile/cpu-profiler.html?hl=zh-cn" target="_blank" rel="external">CPU Profiler指南</a></p><p><img src="http://upload-images.jianshu.io/upload_images/5734256-1cba20678866ba8e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h3 id="2-内存分析器"><a href="#2-内存分析器" class="headerlink" title="2. 内存分析器"></a>2. 内存分析器</h3><p>内存分析器可以帮助你识别内存泄漏和内存流失，从而导致静音，冻结甚至应用程序崩溃。它显示了应用程序内存使用的实时图形，可以捕获堆转储，强制垃圾收集和跟踪内存分配。<br>具体使用<a href="https://developer.android.com/studio/profile/memeory-profiler.html?hl=zh-cn" target="_blank" rel="external">内存分析器指南</a></p><p><img src="http://upload-images.jianshu.io/upload_images/5734256-63bea8ddd2f203f1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h3 id="3-网络分析器"><a href="#3-网络分析器" class="headerlink" title="3. 网络分析器"></a>3. 网络分析器</h3><p>网络分析器允许您监视应用程序的网络活动，检查每个网络请求的有效负载，并链接到生成网络请求的代码。<br>具体使用<a href="https://developer.android.com/studio/profile/network-profiler.html?hl=zh-cn" target="_blank" rel="external">网络分析器指南</a></p><p><img src="http://upload-images.jianshu.io/upload_images/5734256-3b3d28704a7fa811.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h2 id="APK剖析和调试"><a href="#APK剖析和调试" class="headerlink" title="APK剖析和调试"></a>APK剖析和调试</h2><p>Android Studio现在允许对任何APK进行配置和调试</p><p><img src="http://upload-images.jianshu.io/upload_images/5734256-1b9ede067a1470e5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>或在welcome中选择<br><img src="http://upload-images.jianshu.io/upload_images/5734256-8f98954f68fa5abf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>但它不会反编译代码，代码是smail格式的，要正确添加断点和查看堆栈跟踪，需要附加Java源文件和本机调试符号。</p><p><img src="http://upload-images.jianshu.io/upload_images/5734256-cddd64ae635aedac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h2 id="设备文件浏览器"><a href="#设备文件浏览器" class="headerlink" title="设备文件浏览器"></a>设备文件浏览器</h2><p>设备文件资源管理器允许你检查连接的设备的文件系统，并在设备和计算机之间传输文件。这将替代DDMS中可用的文件系统工具。<br>在<strong>View &gt; Tool Windows &gt; Device File Explorer</strong>中打开</p><p><img src="http://upload-images.jianshu.io/upload_images/5734256-9286554e9a901022.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h2 id="自适应图标向导"><a href="#自适应图标向导" class="headerlink" title="自适应图标向导"></a>自适应图标向导</h2><p>Image Asset可以为Android8.0创建自适应启动器图标，同时为旧设备创建传统图标（必须设置compileSdkVersion为26或更高才能使用自适应启动器图标。）</p><p><img src="http://upload-images.jianshu.io/upload_images/5734256-3426f2fd016fdf99.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h2 id="即时应用支持"><a href="#即时应用支持" class="headerlink" title="即时应用支持"></a>即时应用支持</h2><p>Android Instant App能让用户免安装体验你的APP，在项目里可以将某些模块用它来实现。<br>首先要求在SDK Manager中安装Instant Apps开发SDK</p><p><img src="http://upload-images.jianshu.io/upload_images/5734256-123b7cd3e99f3870.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><img src="http://upload-images.jianshu.io/upload_images/5734256-03932f3345fc7c46.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="Android-Things模块"><a href="#Android-Things模块" class="headerlink" title="Android Things模块"></a>Android Things模块</h3><p>新建项目和新建模块向导中的新Android Things模板可帮助开发适用于Android的IOT设备。</p><h3 id="支持字体资源"><a href="#支持字体资源" class="headerlink" title="支持字体资源"></a>支持字体资源</h3><p>为了支持Android 8.0中的新字体资源，Android Studio包含一个字体资源选择器，用于将 字体捆绑到应用程序中或配置项目以下载设备上的字体（如果可用）。布局编辑器还可以预览布局中的字体。</p><p>要尝试下载字体，请确保您的设备或模拟器正在运行Google Play Services v11.2.63或更高版本。（国内受限…）</p><p><img src="http://upload-images.jianshu.io/upload_images/5734256-817fdf98f336a7da.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h3 id="布局编辑器"><a href="#布局编辑器" class="headerlink" title="布局编辑器"></a>布局编辑器</h3><p>更新了一些增强功能，包括以下内容：</p><ul><li>新的工具栏布局和图标。</li><li>在组件树中更新布局。</li><li>改进的拖放视图插入。</li><li>在编辑器下面显示新的错误面板，显示修复建议的所有问题（如果可用）。</li><li>用于ConstraintLayout的各种UI增强功能</li></ul>]]></content:encoded>
      
      <comments>http://yoursite.com/2017/10/27/%E4%BD%A0%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84Android%20Studio%203.0%E6%96%B0%E7%89%B9%E6%96%B0/#disqus_thread</comments>
    </item>
    
    <item>
      <title>View基础</title>
      <link>http://yoursite.com/2017/10/24/View%E5%9F%BA%E7%A1%80/</link>
      <guid>http://yoursite.com/2017/10/24/View%E5%9F%BA%E7%A1%80/</guid>
      <pubDate>Tue, 24 Oct 2017 12:53:32 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;View的位置参数&quot;&gt;&lt;a href=&quot;#View的位置参数&quot; class=&quot;headerlink&quot; title=&quot;View的位置参数&quot;&gt;&lt;/a&gt;View的位置参数&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/5734256-9da460954b65cab0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="View的位置参数"><a href="#View的位置参数" class="headerlink" title="View的位置参数"></a>View的位置参数</h2><p><img src="http://upload-images.jianshu.io/upload_images/5734256-9da460954b65cab0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><a id="more"></a><h2 id="MotionEvent"><a href="#MotionEvent" class="headerlink" title="MotionEvent"></a>MotionEvent</h2><p>包括三种类型：</p><ol><li>ACTION_DOWN</li><li>ACTION_MOVE</li><li>ACTION_UP</li></ol><p><strong>getX/getY</strong> 相对于View的坐标<br><strong>getRawX/getRawY</strong> 相对于手机屏幕的坐标</p><h2 id="TouchSlop-滑动的最小距离"><a href="#TouchSlop-滑动的最小距离" class="headerlink" title="TouchSlop-滑动的最小距离"></a>TouchSlop-滑动的最小距离</h2><p>获取该常量（8dp）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ViewConfiguration.get(getContext()).getScaledTouchSlop()</div></pre></td></tr></table></figure></p><h2 id="VelocityTracker-速度追踪"><a href="#VelocityTracker-速度追踪" class="headerlink" title="VelocityTracker-速度追踪"></a>VelocityTracker-速度追踪</h2><p>获取<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">VelocityTracker mVelocityTracker=VelocityTracker.obtain();</div></pre></td></tr></table></figure></p><p>测速<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//跟踪当前事件</div><div class="line">mVelocityTracker.addMovement(event);</div><div class="line">//获取速度</div><div class="line">mVelocityTracker.computeCurrentVelocity(1000);//设置测速时间段</div><div class="line">float xVelocity=mVelocityTracker.getXVelocity();</div><div class="line">float yVelocity=mVelocityTracker.getYVelocity();</div></pre></td></tr></table></figure></p><p>回收<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">//回收，释放内存</div><div class="line">mVelocityTracker.clear();</div><div class="line">mVelocityTracker.recycle();</div></pre></td></tr></table></figure></p><h2 id="GestureDetector-手势检测"><a href="#GestureDetector-手势检测" class="headerlink" title="GestureDetector-手势检测"></a>GestureDetector-手势检测</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mGestureDetector=new GestureDetector(context, this);//实现OnGestureListener接口</div><div class="line">mGestureDetector.setIsLongpressEnabled(false);//解决长按屏幕无法拖动的现象</div><div class="line">mGestureDetector.setOnDoubleTapListener(this);//实现OnDoubleTapListener</div></pre></td></tr></table></figure><p>接管onTouchEvent方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">boolean consume=mGestureDetector.onTouchEvent(event);</div><div class="line">return consume;</div></pre></td></tr></table></figure></p><p><strong>Tip:</strong> 监听滑动相关，自己在onTouchEvent中实现；监听双击之类，用GestureDetector</p><h2 id="Scroller-弹性滑动"><a href="#Scroller-弹性滑动" class="headerlink" title="Scroller-弹性滑动"></a>Scroller-弹性滑动</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public void smoothScrollTo(int destX,int destY,int duration)&#123;</div><div class="line">        mScroller.startScroll(getScrollX(),getScrollY(),destX-getScrollX(),destY-getScrollY(),duration);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void smoothScrollBy(int x,int y,int duration)&#123;</div><div class="line">        mScroller.startScroll(getScrollX(),getScrollY(),x+getScrollX(),y+getScrollY(),duration);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void computeScroll() &#123;</div><div class="line">        if (mScroller.computeScrollOffset()) &#123;</div><div class="line">            scrollTo(mScroller.getCurrX(),mScroller.getCurrY());</div><div class="line">            postInvalidate();</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>http://yoursite.com/2017/10/24/View%E5%9F%BA%E7%A1%80/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Android Picture详解</title>
      <link>http://yoursite.com/2017/10/22/Android%20Picture%E8%AF%A6%E8%A7%A3/</link>
      <guid>http://yoursite.com/2017/10/22/Android%20Picture%E8%AF%A6%E8%A7%A3/</guid>
      <pubDate>Sun, 22 Oct 2017 06:35:45 GMT</pubDate>
      <description>
      
        &lt;p&gt;Picture是自定义view中一个实用的工具，对应Canvas中的drawPicture方法，当然除了这个外还有另外两个方法用于绘制Picture：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Picture自身的draw(Canvas canvas)&lt;/li&gt;
&lt;li&gt;PictureDrawable的draw(Canvas canvas)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面会讨论三种方式的不同之处，首先来看下Picture的用途和主要方法&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>Picture是自定义view中一个实用的工具，对应Canvas中的drawPicture方法，当然除了这个外还有另外两个方法用于绘制Picture：</p><ul><li>Picture自身的draw(Canvas canvas)</li><li>PictureDrawable的draw(Canvas canvas)</li></ul><p>下面会讨论三种方式的不同之处，首先来看下Picture的用途和主要方法</p><a id="more"></a><h2 id="Picture简介"><a href="#Picture简介" class="headerlink" title="Picture简介"></a>Picture简介</h2><p>Picture是用来干嘛的呢？官方参考是这样介绍的</p><blockquote><p>A Picture records drawing calls (via the canvas returned by beginRecording) and can then play them back into Canvas (via draw(Canvas) or drawPicture(Picture)). For most content (e.g. text, lines, rectangles), drawing a sequence from a picture can be faster than the equivalent API calls, since the picture performs its playback without incurring any method-call overhead.</p></blockquote><p>也就是说当调用Picture的beginRecording的方法后，会返回一个Canvas，在这上面绘制的各种内容会被录制下来，之后需要的时候，直接绘制Picture会比在绘制一遍各种内容快一些。通常当有些内容我们需要绘制多次时，可以先用它录制下来，之后直接把录制的Picture绘制出来就可以了</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>Picture()</td><td>构造方法</td></tr><tr><td>Picture(Picture src)</td><td>构造方法，在已有Picture基础上再进行录制</td></tr><tr><td>public Canvas beginRecording (int width, int height)</td><td>开始录制，在返回的Canvas上进行绘制</td></tr><tr><td>public void endRecording ()</td><td>结束录制</td></tr><tr><td>public void draw (Canvas canvas)</td><td>将Picture绘制到Canvas上</td></tr><tr><td>public int getWidth ()</td><td>获取宽度</td></tr><tr><td>public int getHeight ()</td><td>获取高度</td></tr></tbody></table><p>还有两个createFromStream、writeToStream在API 18已经被弃用。上面方法理解起来也容易，beginRecording和endRecording对应，开始和结束录制，在它们两个间进行绘制操作</p><h2 id="三种不同绘制方法的使用和区别"><a href="#三种不同绘制方法的使用和区别" class="headerlink" title="三种不同绘制方法的使用和区别"></a>三种不同绘制方法的使用和区别</h2><p>录制的内容不会直接显示，只是存储起来，想要将Picture中的内容显示出来就需要手动调用=绘制方法，有3种方法：</p><ol><li>使用Picture提供的draw方法绘制</li><li>使用Canvas提供的drawPicture方法绘制</li><li>将Picture包装成为PictureDrawable，使用PictureDrawable的draw方法绘制</li></ol><p>下面来分别看看三种方法的使用。</p><h3 id="Picture的draw方法"><a href="#Picture的draw方法" class="headerlink" title="Picture的draw方法"></a>Picture的draw方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">    private Picture mPicture=new Picture();</div><div class="line"></div><div class="line"></div><div class="line">    public CanvasView(Context context, @Nullable AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line">        mPaint=new Paint();</div><div class="line">        mPaint.setStrokeWidth(24);</div><div class="line">        mPaint.setStyle(Paint.Style.FILL);</div><div class="line">        mPaint.setStrokeCap(Paint.Cap.ROUND);</div><div class="line"></div><div class="line">        recording();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        super.onDraw(canvas);</div><div class="line">        mPicture.draw(canvas);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void recording() &#123;</div><div class="line">        Canvas canvas=mPicture.beginRecording(400, 400);</div><div class="line">        canvas.drawPoint(0, 0, mPaint);</div><div class="line">        mPaint.setColor(Color.RED);</div><div class="line">        canvas.drawPoint(250, 250, mPaint);</div><div class="line">        mPaint.setColor(Color.BLUE);</div><div class="line">        canvas.drawPoint(500, 500, mPaint);</div><div class="line"></div><div class="line">        mPicture.endRecording();</div><div class="line">    &#125;</div><div class="line">...</div></pre></td></tr></table></figure><p>我们分别绘制三个点(0, 0)、(250, 250)、(500, 500)，但是传入的宽高是400，那第三个点会怎样呢</p><p><img src="http://upload-images.jianshu.io/upload_images/5734256-277ca7d7f7346dc1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>可以看到三个点都绘制出来了，说明传入的宽和高并不是限定画布绘制的范围，而是其相对大小（等下再具体解释），而且绘制时是将Picture的左上角和Canvas坐标轴对齐绘制<br>例如，将canvas坐标轴移到中心<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        super.onDraw(canvas);</div><div class="line">        canvas.translate(getWidth()/2f, getHeight()/2f);</div><div class="line">        mPicture.draw(canvas);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><img src="http://upload-images.jianshu.io/upload_images/5734256-95816c004477db6e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>从上面得出，Picture的draw方法是将Picture不做任何变化原样绘制到画布上</p><h3 id="Canvas的drawPicture方法"><a href="#Canvas的drawPicture方法" class="headerlink" title="Canvas的drawPicture方法"></a>Canvas的drawPicture方法</h3><p>这个方法有三种重载，一个参数的drawPicture(Picture picture)和Picture的draw方法效果相同，还有两个重载是通过RectF和Rect对Picture绘制进行一些控制<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        super.onDraw(canvas);</div><div class="line">        canvas.drawPicture(mPicture, new RectF(0, 200, mPicture.getWidth(), 200+mPicture.getHeight()));</div><div class="line">        canvas.drawPicture(mPicture, new RectF(0, 0,mPicture.getWidth(), mPicture.getHeight()/2));</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p><p><img src="http://upload-images.jianshu.io/upload_images/5734256-b9b088a231758687.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>可以看到第一次绘制的形状未变，只不过在y轴上上移了200px，第二次将高减为一般半，绘制出的Picture在y轴方向压缩了一半，也就是rect并不是对图形进行裁剪，而是缩小或放大，和Picture本身的width和height相对应。看源码更清楚：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">     * Draw the picture, stretched to fit into the dst rectangle.</div><div class="line">     */</div><div class="line">    public void drawPicture(@NonNull Picture picture, @NonNull RectF dst) &#123;</div><div class="line">        save();</div><div class="line">        translate(dst.left, dst.top);</div><div class="line">        if (picture.getWidth() &gt; 0 &amp;&amp; picture.getHeight() &gt; 0) &#123;</div><div class="line">            scale(dst.width() / picture.getWidth(), dst.height() / picture.getHeight());</div><div class="line">        &#125;</div><div class="line">        drawPicture(picture);</div><div class="line">        restore();</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p><h3 id="PictureDrawable的draw方法"><a href="#PictureDrawable的draw方法" class="headerlink" title="PictureDrawable的draw方法"></a>PictureDrawable的draw方法</h3><p>要控制在画布上的绘制区域，就需要使用PictureDrawable，设置bound<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// 包装成为PictureDrawable</div><div class="line">PictureDrawable drawable = new PictureDrawable(mPicture);</div><div class="line">// 设置绘制区域</div><div class="line">drawable.setBounds(0,0,250,mPicture.getHeight());</div><div class="line">// 绘制</div><div class="line">drawable.draw(canvas);</div></pre></td></tr></table></figure></p><p><img src="http://upload-images.jianshu.io/upload_images/5734256-657cda9477915226.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>可以看到绘制区域被限定在(0, 0,250, 400)范围内，而不像上面对Picture进行缩放，这里注意是限定绘制区域，而不是对Picture进行裁剪</p><p>综上，</p><ul><li>一般并不使用Picture提供的draw方法，它在比较低版本的系统上绘制后可能会影响Canvas状态</li><li>如果想对绘制位置和比例进行控制用Canvas提供的drawPicture方法绘制</li><li>如果想设置绘制区域则使用PictureDrawable的draw方法</li></ul>]]></content:encoded>
      
      <comments>http://yoursite.com/2017/10/22/Android%20Picture%E8%AF%A6%E8%A7%A3/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
